Candidate:	keys' code adapted from m
Candidate:	keys(key) {
	if (!key) {

Candidate:	key) {
	if (!key) {
		key
Candidate:	key) {
		key = event;
		k
Candidate:	key = event;
		key.which 
Candidate:	key.which = key.keycode;

Candidate:	key.keycode;
	}
	if (key.
Candidate:	keycode;
	}
	if (key.whic
Candidate:	key.which == 84) {
		togg
Candidate:	key.which) {
			case 10: 
Candidate:	key.target && isparentors
Candidate:	key.target, 'controls')) 
Candidate:	key
			case 40: // downke
Candidate:	key
				if(number != unde
Candidate:	key
			case 38: // upkey

Candidate:	key
				if(number != unde
Candidate:	key.which < 48 || key.whi
Candidate:	key.which > 57) {
			numb
Candidate:	key.target && isparentors
Candidate:	key.target, 'controls')) 
Candidate:	key.which - 48);
		}
	}
	
Candidate:	key="t" id="toggle" href=
Candidate:	key="z" id="prev" href="j
Candidate:	key="x" id="next" href="j
Candidate:	key trap fix, new functio
Candidate:	keycode;
	}
	try {
		modi
Candidate:	key = e.ctrlkey || e.altk
Candidate:	key || e.altkey || e.meta
Candidate:	key || e.metakey;
	}
	cat
Candidate:	key;
	}
	catch(e) {
		mod
Candidate:	key = false;
	}
	return m
Candidate:	key || e.which == 0;
}

f
Candidate:	keyup = keys;
		document.
Candidate:	keys;
		document.onkeypre
Candidate:	keypress = trap;
		docume
Candidate:	api.identity"]){throw new
Candidate:	api");}if(!this.cookienam
Candidate:	api.notification"]){this.
Candidate:	api.read":true,"dojo.data
Candidate:	api.identity":true};this.
Candidate:	api.identity"]=_402;for(i
Candidate:	api.identity"]=number;}fo
Candidate:	api.identity"];if(_40d===
Candidate:	api.identity"];if(_41d===
Candidate:	tokens:_4fb,bundle:_4f6};
Candidate:	tokens,_501=info.bundle;v
Candidate:	key in _63){this._connect
Candidate:	keylistener(this.domnode,
Candidate:	keycode:dojo.keys[key],ct
Candidate:	keys[key],ctrlkey:false,a
Candidate:	key],ctrlkey:false,altkey
Candidate:	key:false,altkey:false,sh
Candidate:	key:false,shiftkey:false}
Candidate:	key:false},this,function(
Candidate:	key];return function(_66)
Candidate:	key(_65,_66);};}(),this.t
Candidate:	key:function(_70,_71){if(
Candidate:	key=navigator.appversion.
Candidate:	key":"metakey";dojo.dnd.g
Candidate:	key";dojo.dnd.getcopykeys
Candidate:	keystate=function(e){retu
Candidate:	key];};dojo.dnd._uniqueid
Candidate:	key:function(evt){if(evt.
Candidate:	keycode){var node=evt.tar
Candidate:	key&&evt.keycode==dojo.ke
Candidate:	keycode==dojo.keys.tab){i
Candidate:	keys.tab){if(this._lastfo
Candidate:	keycode==dojo.keys.escape
Candidate:	keys.escape){this.hide();
Candidate:	keycode!=dojo.keys.tab){d
Candidate:	keys.tab){dojo.stopevent(
Candidate:	keypress",this,"_onkey"))
Candidate:	key"));var ev=typeof (doc
Candidate:	keypress","_onkey");var e
Candidate:	key");var ev=typeof (docu
Candidate:	key:function(evt){if(evt.
Candidate:	keycode==dojo.keys.escape
Candidate:	keys.escape){this.oncance
Candidate:	key&&evt.keycode==dojo.ke
Candidate:	keycode==dojo.keys.tab){i
Candidate:	keys.tab){if(this._lastfo
Candidate:	keycode==dojo.keys.tab){e
Candidate:	keys.tab){evt.stoppropaga
Candidate:	keyhandlers={};this.conte
Candidate:	key_ctrl;var exec=functio
Candidate:	keyhandler("b",ctrl,exec(
Candidate:	keyhandler("i",ctrl,exec(
Candidate:	keyhandler("u",ctrl,exec(
Candidate:	keyhandler("a",ctrl,exec(
Candidate:	keyhandler("s",ctrl,funct
Candidate:	keyhandler("1",ctrl,exec(
Candidate:	keyhandler("2",ctrl,exec(
Candidate:	keyhandler("3",ctrl,exec(
Candidate:	keyhandler("4",ctrl,exec(
Candidate:	keyhandler("\\",ctrl,exec
Candidate:	keyhandler("z",ctrl,exec(
Candidate:	keypress","onkeydown","on
Candidate:	keydown","onkeyup","oncli
Candidate:	keyup","onclick"],capture
Candidate:	keydown:function(e){if(do
Candidate:	keycode===dojo.keys.backs
Candidate:	keys.backspace&&this.docu
Candidate:	keycode&&e.keycode<=90)||
Candidate:	keycode<=90)||(e.keycode>
Candidate:	keycode>=37&&e.keycode<=4
Candidate:	keycode<=40)){e.charcode=
Candidate:	keycode;this.onkeypress(e
Candidate:	keypress(e);}}}else{if(do
Candidate:	keycode==dojo.keys.tab&&!
Candidate:	keys.tab&&!e.shiftkey&&!e
Candidate:	key&&!e.ctrlkey&&!e.altke
Candidate:	key&&!e.altkey&&this.ifra
Candidate:	key&&this.iframe){this.if
Candidate:	keycode==dojo.keys.tab&&e
Candidate:	keys.tab&&e.shiftkey){if(
Candidate:	key){if(this.toolbar){thi
Candidate:	keyup:function(e){return;
Candidate:	key_ctrl:1,key_shift:2,on
Candidate:	key_shift:2,onkeypress:fu
Candidate:	keypress:function(e){var 
Candidate:	key?this.key_ctrl:0|e.shi
Candidate:	key_ctrl:0|e.shiftkey?thi
Candidate:	key?this.key_shift:0;var 
Candidate:	key_shift:0;var key=e.key
Candidate:	key=e.keychar||e.keycode;
Candidate:	keychar||e.keycode;if(thi
Candidate:	keycode;if(this._keyhandl
Candidate:	keyhandlers[key]){var _1a
Candidate:	key]){var _1a1=this._keyh
Candidate:	keyhandlers[key],i=0,h;wh
Candidate:	key],i=0,h;while((h=_1a1[
Candidate:	keypressed(e);}),1);},add
Candidate:	keyhandler:function(key,_
Candidate:	key,_1a5,_1a6){if(!dojo.i
Candidate:	keyhandlers[key])){this._
Candidate:	key])){this._keyhandlers[
Candidate:	keyhandlers[key]=[];}this
Candidate:	key]=[];}this._keyhandler
Candidate:	keyhandlers[key].push({mo
Candidate:	key].push({modifiers:_1a5
Candidate:	keypressed:function(e){th
Candidate:	key;while((m=reg.exec(s))
Candidate:	key=m[1];if(key.substr(0,
Candidate:	key.substr(0,3)!="_dj"){i
Candidate:	key=="src"||key=="href"){
Candidate:	key=="href"){if(node.geta
Candidate:	key,node.getattribute("_d
Candidate:	key=="class"){_1da.push([
Candidate:	key,node.classname]);}els
Candidate:	key,node.getattribute(key
Candidate:	key)]);}}}}else{var attr,
Candidate:	keynavcontainer],{templat
Candidate:	keynavhandlers(this.islef
Candidate:	keys.left_arrow]:[dojo.ke
Candidate:	keys.right_arrow],this.is
Candidate:	keys.right_arrow]:[dojo.k
Candidate:	keys.left_arrow]);},start
Candidate:	keynavchildren();}});dojo
Candidate:	keydown:_ondropdownkeydow
	KEY FOUND:	keydown:_ondropdownkeydow
Candidate:	keydown,onblur:_ondropdow
Candidate:	keypress:_onkey\"\n\t><di
Candidate:	key\"\n\t><div class='dij
Candidate:	keydown){this._onarrowcli
Candidate:	keydown=false;},_ondropdo
Candidate:	keydown:function(e){this.
Candidate:	keydown=true;},_ondropdow
Candidate:	keydown=false;},_onkey:fu
Candidate:	key:function(e){if(this.d
Candidate:	keycode==dojo.keys.down_a
Candidate:	keys.down_arrow){if(!this
Candidate:	keypress:_onkey\"\n\t\t\t
Candidate:	key\"\n\t\t\tstatemodifie
Candidate:	key":"ctrlkey"],[_226[cmd
Candidate:	key"],[_226[cmd]])]));}re
Candidate:	keydown:function(e){if(!t
Candidate:	keydown",arguments);retur
Candidate:	keycode,ks=dojo.keys;if(e
Candidate:	keys;if(e.ctrlkey){if(k==
Candidate:	key){if(k===90||k===122){
Candidate:	keydown",arguments);switc
Candidate:	key&&!e.altkey&&!e.metake
Candidate:	key&&!e.metakey){this.end
Candidate:	key){this.endediting();if
Candidate:	keycode==88){this.begined
Candidate:	key&&!e.altkey&&!e.metake
Candidate:	key&&!e.metakey&&(e.keyco
Candidate:	key&&(e.keycode<dojo.keys
Candidate:	keycode<dojo.keys.f1||e.k
Candidate:	keys.f1||e.keycode>dojo.k
Candidate:	keycode>dojo.keys.f15)){t
Candidate:	keys.f15)){this.beginedit
Candidate:	keynavcontainer],{constru
Candidate:	keypress:_onkeypress\">"+
Candidate:	keypress\">"+"<tbody clas
Candidate:	keynavhandlers([dojo.keys
Candidate:	keys.up_arrow],[dojo.keys
Candidate:	keys.down_arrow]);},start
Candidate:	keynavchildren();},onexec
Candidate:	keypress:function(evt){if
Candidate:	key||evt.altkey){return;}
Candidate:	key){return;}switch(evt.k
Candidate:	keycode){case dojo.keys.r
Candidate:	keys.right_arrow:this._mo
Candidate:	keys.left_arrow:if(this.p
Candidate:	keydown",this,"_contextke
Candidate:	key"),dojo.connect(cn,"on
Candidate:	key:function(e){this._con
Candidate:	keycode==dojo.keys.f10){d
Candidate:	keys.f10){dojo.stopevent(
Candidate:	key&&e.type=="keydown"){v
Candidate:	keydown"){var _e={target:
Candidate:	keypress: _ontitlekey,onf
Candidate:	key,onfocus:_handlefocus,
Candidate:	key:function(e){if(e.keyc
Candidate:	keycode==dojo.keys.enter|
Candidate:	keys.enter||e.charcode==d
Candidate:	keys.space){this.toggle()
Candidate:	keycode==dojo.keys.down_a
Candidate:	keys.down_arrow){if(this.
Candidate:	keypress:_onkeypress\">\n
Candidate:	keypress\">\n\t<div class
Candidate:	keypress:function(e){if(e
Candidate:	key){return;}var _320=dij
Candidate:	key&&!e.ctrlkey&&!e.shift
Candidate:	key&&!e.shiftkey&&!e.meta
Candidate:	key&&!e.metakey){_321=(st
Candidate:	key){_321=(string.fromcha
Candidate:	keynav({node:_320,key:_32
Candidate:	key:_321});dojo.stopevent
Candidate:	keyhandlermap;if(!map){ma
Candidate:	keys.enter]="_onenterkey"
Candidate:	key";map[dojo.keys.left_a
Candidate:	keys.left_arrow]="_onleft
Candidate:	keys.right_arrow]="_onrig
Candidate:	keys.up_arrow]="_onuparro
Candidate:	keys.down_arrow]="_ondown
Candidate:	keys.home]="_onhomekey";m
Candidate:	key";map[dojo.keys.end]="
Candidate:	keys.end]="_onendkey";thi
Candidate:	key";this._keyhandlermap=
Candidate:	keyhandlermap=map;}if(thi
Candidate:	keyhandlermap[e.keycode])
Candidate:	keycode]){this[this._keyh
Candidate:	keyhandlermap[e.keycode]]
Candidate:	keycode]]({node:_320,item
Candidate:	key:function(_323){this._
Candidate:	key:function(){var _332=t
Candidate:	key:function(_333){var _3
Candidate:	keynav:function(_337){var
Candidate:	key=_337.key;do{node=this
Candidate:	key;do{node=this._navtone
Candidate:	key));if(node&&node.istre
Candidate:	keyup,onkeypress:_onkeypr
Candidate:	keypress:_onkeypress'\n\t
Candidate:	keypress'\n\tautocomplete
Candidate:	keyup:function(){}});}if(
Candidate:	keypress: _onkeypress\" \
Candidate:	keypress\" \n\t><input do
Candidate:	keypress:function(e){if(t
Candidate:	keycode==dojo.keys.escape
Candidate:	keys.escape){dojo.stopeve
Candidate:	keycode==dojo.keys.enter)
Candidate:	keys.enter){dojo.stopeven
Candidate:	key in item){if((key!==th
Candidate:	key!==this._storerefpropn
Candidate:	key!==this._itemnumpropna
Candidate:	key!==this._rootitempropn
Candidate:	key);}}return _3c6;},hasa
Candidate:	key in _3dd.query){var _3
Candidate:	key];if(typeof _3e3==="st
Candidate:	key]=dojo.data.util.filte
Candidate:	key in _3dd.query){var _3
Candidate:	key];if(!self._containsva
Candidate:	key,_3e3,_3e1[key])){_3e5
Candidate:	key])){_3e5=false;}}}if(_
Candidate:	key;for(i=0;i<this._array
Candidate:	key in item){if(key!==thi
Candidate:	key!==this._rootitempropn
Candidate:	key];if(_400!==null){if(!
Candidate:	key]=[_400];}}else{item[k
Candidate:	key]=[null];}}_3fe[key]=k
Candidate:	key]=key;}}while(_3fe[thi
Candidate:	key;}}while(_3fe[this._st
Candidate:	key in item){_401=item[ke
Candidate:	key];for(var j=0;j<_401.l
Candidate:	keyup,onkeypress:_onkeypr
Candidate:	keypress:_onkeypress' aut
Candidate:	keypress' autocomplete=\"
Candidate:	keyup:function(evt){this.
Candidate:	keypress, onkeyup, onfocu
Candidate:	keyup, onfocus, compositi
Candidate:	keyevents");te.initkeyeve
Candidate:	keyevent("keypress",true,
Candidate:	keypress",true,true,null,
Candidate:	keypress:function(evt){if
Candidate:	key||(evt.ctrlkey&&evt.ch
Candidate:	key&&evt.charcode!=118)){
Candidate:	key(evt);}switch(evt.keyc
Candidate:	keycode){case dojo.keys.p
Candidate:	keys.page_down:case dojo.
Candidate:	keys.down_arrow:if(!this.
Candidate:	key_esc){this._arrowpress
Candidate:	key_backspace=false;this.
Candidate:	key_esc=false;break;case 
Candidate:	keys.page_up:case dojo.ke
Candidate:	keys.up_arrow:if(this._is
Candidate:	key_backspace=false;this.
Candidate:	key_esc=false;break;case 
Candidate:	keys.enter:var _453;if(th
Candidate:	keys.tab:var _454=this.ge
Candidate:	key_backspace=false;this.
Candidate:	key_esc=false;if(this._po
Candidate:	keys.space:this._prev_key
Candidate:	key_backspace=false;this.
Candidate:	key_esc=false;if(this._is
Candidate:	keys.escape:this._prev_ke
Candidate:	key_backspace=false;this.
Candidate:	key_esc=true;this._hidere
Candidate:	keys.delete:case dojo.key
Candidate:	keys.backspace:this._prev
Candidate:	key_esc=false;this._prev_
Candidate:	key_backspace=true;_452=t
Candidate:	keys.right_arrow:case doj
Candidate:	keys.left_arrow:this._pre
Candidate:	key_backspace=false;this.
Candidate:	key_esc=false;break;defau
Candidate:	key_backspace=false;this.
Candidate:	key_esc=false;if(dojo.isi
Candidate:	key_backspace&&(_458.quer
Candidate:	key){if(!this._popupwidge
Candidate:	key+"*";var _469=this.sto
Candidate:	keypress({charcode:-1});}
Candidate:	key:function(evt){switch(
Candidate:	keycode){case dojo.keys.d
Candidate:	keys.down_arrow:this._hig
Candidate:	keys.page_down:this.paged
Candidate:	keys.up_arrow:this._highl
Candidate:	keys.page_up:this.pageup(
Candidate:	keyup:function(evt){},_do
Candidate:	keypress:_onkeypress\"\n\
Candidate:	keypress\"\n\twairole=\"p
Candidate:	keyup\"\n\t\t\t\twairole=
Candidate:	keycode==dojo.keys.up_arr
Candidate:	keys.up_arrow)?this.uparr
Candidate:	keycode:dojo.keys.up_arro
Candidate:	keys.up_arrow,ctrlkey:fal
Candidate:	key:false,altkey:false,sh
Candidate:	key:false,shiftkey:false}
Candidate:	key:false},this,"_typemat
Candidate:	keycode:dojo.keys.down_ar
Candidate:	keys.down_arrow,ctrlkey:f
Candidate:	key:false,altkey:false,sh
Candidate:	key:false,shiftkey:false}
Candidate:	key:false},this,"_typemat
Candidate:	keypress:_onkeypress,oncl
Candidate:	keypress,onclick:_onhandl
Candidate:	keypress:function(e){if(t
Candidate:	key||e.ctrlkey){return;}s
Candidate:	key){return;}switch(e.key
Candidate:	keycode){case dojo.keys.h
Candidate:	keys.home:this.setvalue(t
Candidate:	keys.end:this.setvalue(th
Candidate:	keys.up_arrow:case (this.
Candidate:	keys.left_arrow:dojo.keys
Candidate:	keys.right_arrow):case do
Candidate:	keys.page_up:this.increme
Candidate:	keys.down_arrow:case (thi
Candidate:	keys.right_arrow:dojo.key
Candidate:	keys.left_arrow):case doj
Candidate:	keys.page_down:this.decre
Candidate:	keypress",arguments);retu
Candidate:	keycode==dojo.keys.page_d
Candidate:	keys.page_down?-this.page
Candidate:	keycode==dojo.keys.page_u
Candidate:	keys.page_up?this.pageinc
Candidate:	keypress:_onkeypress,oncl
Candidate:	keypress,onclick:_onhandl
Candidate:	keypress",this._onkeypres
Candidate:	keypress);this.connect(th
Candidate:	keypress:function(e){if(e
Candidate:	keycode==dojo.keys.tab&&!
Candidate:	keys.tab&&!e.shiftkey&&!e
Candidate:	key&&!e.ctrlkey&&!e.altke
Candidate:	key&&!e.altkey&&this.ifra
Candidate:	key&&this.iframe){this.if
Candidate:	keycode==dojo.keys.enter)
Candidate:	keys.enter){e.stoppropaga
Candidate:	keypress",arguments)&&thi
Candidate:	keyevents");te.initkeyeve
Candidate:	keyevent("keypress",true,
Candidate:	keypress",true,true,null,
Candidate:	key,e.altkey,e.shiftkey,e
Candidate:	key,e.shiftkey,e.metakey,
Candidate:	key,e.metakey,e.keycode,e
Candidate:	key,e.keycode,e.charcode)
Candidate:	keycode,e.charcode);this.
Candidate:	keypress",this._onkeypres
Candidate:	keypress);},startup:funct
Candidate:	keypress:function(e){dojo
Candidate:	keypress",[{e:e,page:this
Candidate:	keypress' class='dijitsta
Candidate:	keypress",this,"oncontain
Candidate:	keypress")];},onstartup:f
Candidate:	keypress:function(e){if(t
Candidate:	key){return;}var _639=tru
Candidate:	key||!e._djpage){var k=do
Candidate:	keys;switch(e.keycode){ca
Candidate:	keycode){case k.left_arro
Candidate:	key){if(e.keycode==k.tab)
Candidate:	keycode==k.tab){this.adja
Candidate:	key).onclick();dojo.stope
Candidate:	keychar=="w"){if(this._cu
Candidate:	keypress:function(info){i
Candidate:	keypress(info.e);}});dojo
Candidate:	keypress:function(e){if(t
Candidate:	key){return;}var k=dojo.k
Candidate:	keys;switch(e.keycode){ca
Candidate:	keycode){case k.left_arro
Candidate:	key&&e.keycode==k.tab){th
Candidate:	keycode==k.tab){this._adj
Candidate:	key)._ontitleclick();dojo
Candidate:	keypress:_ontitlekeypress
	KEY FOUND:	keypress:_ontitlekeypress
Candidate:	keypress,onfocus:_handlef
Candidate:	keypress:function(evt){ev
Candidate:	keypress(evt);},_setselec
Candidate:	keypress:onkeypress'></di
Candidate:	keypress'></div>",tabposi
Candidate:	apis, you may want to use
Candidate:	keypress",this,function(e
Candidate:	keycode==dojo.keys.escape
Candidate:	keys.escape&&_69.oncancel
Candidate:	keycode==dojo.keys.tab){d
Candidate:	keys.tab){dojo.stopevent(
Candidate:	keylistener:function(_96,
Candidate:	keypress",this,function(e
Candidate:	keycode==_97.keycode&&(!_
Candidate:	keycode&&(!_97.charcode||
Candidate:	key===undefined||_97.ctrl
Candidate:	key==evt.ctrlkey)&&(_97.a
Candidate:	key)&&(_97.altkey===undef
Candidate:	key===undefined||_97.altk
Candidate:	key==evt.ctrlkey)&&(_97.s
Candidate:	key)&&(_97.shiftkey===und
Candidate:	key===undefined||_97.shif
Candidate:	key==evt.ctrlkey)){dojo.s
Candidate:	key)){dojo.stopevent(evt)
Candidate:	keyup",this,function(evt)
Candidate:	keylistener(_aa,_ab,_ac,_
Candidate:	keyclick:["input","button
Candidate:	keyclick[obj.nodename]){_
Candidate:	keydown",this,function(e)
Candidate:	keycode==dojo.keys.enter)
Candidate:	keys.enter){return (dojo.
Candidate:	keycode==dojo.keys.space)
Candidate:	keys.space){dojo.stopeven
Candidate:	keyup",this,function(e){i
Candidate:	keycode==dojo.keys.space)
Candidate:	keys.space){return dojo.i
Candidate:	key,_12f){var _130=dojo.g
Candidate:	key,false,map);if(_12f){_
Candidate:	key);}return _130.tostrin
Candidate:	key){if(key.charat(0)=="!
Candidate:	key.charat(0)=="!"){_138=
Candidate:	key.substr(1)];}if(typeof
Candidate:	key);}if(!_138){return ""
Candidate:	key.charat(0)=="!"?_138:_
Candidate:	key=_155||_154;var _159=_
Candidate:	key];if(_159){return _159
Candidate:	key]=_155);}else{return (
Candidate:	key]=dijit._templated._cr
Candidate:	key in _15c){var _15e=_15
Candidate:	key];if(!isnan(_15e.nodet
Candidate:	key];}});}(function(){var
Candidate:	keynavcontainer",[dijit._
Candidate:	keynavcodes:{},connectkey
Candidate:	keynavhandlers:function(_
Candidate:	keynavcodes={};var prev=d
Candidate:	keypress","_oncontainerke
Candidate:	keypress");if(dojo.isie){
Candidate:	keynavchildren:function()
Candidate:	keynavcontainer.superclas
Candidate:	keypress:function(evt){if
Candidate:	key||evt.altkey){return;}
Candidate:	key){return;}var func=thi
Candidate:	keynavcodes[evt.keycode];
Candidate:	keycode];if(func){func();
Candidate:	keypress:function(e){if(e
Candidate:	keycode==dojo.keys.escape
Candidate:	keys.escape&&!e.shiftkey&
Candidate:	key&&!e.ctrlkey&&!e.altke
Candidate:	key&&!e.altkey){var v=thi
Candidate:	key){var v=this.getvalue(
Candidate:	secret", except: [:index,
Candidate:	password: "secret", excep
Candidate:	secret", except: [:index,
Candidate:	password: "secret", excep
Candidate:	apis subject to change wi
Candidate:	key","mobile"];var t;whil
Candidate:	key in it){var _1b8;if(ty
Candidate:	key)=="number"){_1b8="\""
Candidate:	key+"\"";}else{if(typeof 
Candidate:	key)=="string"){_1b8=dojo
Candidate:	key);}else{continue;}}val
Candidate:	key],_1ac,_1ae);if(typeof
Candidate:	keypress"?fp:function(e){
Candidate:	keypress":del._setkeychar
Candidate:	keychar(evt);break;}retur
Candidate:	keychar:function(evt){evt
Candidate:	keychar=(evt.charcode?str
Candidate:	keys={backspace:8,tab:9,c
Candidate:	keycode=function(e,code){
Candidate:	keycode=code);}catch(e){r
Candidate:	keypress"){var kd=node.on
Candidate:	keydown;if(!kd||!kd._list
Candidate:	keydown){del.add(node,"on
Candidate:	keydown",del._stealthkeyd
Candidate:	keydown);node.onkeydown._
Candidate:	keydown._stealthkeydown=t
Candidate:	keydown=true;}}return iel
Candidate:	keys(evt);},_fixkeys:func
Candidate:	keys:function(evt){switch
Candidate:	keypress":var c=("charcod
Candidate:	keycode);if(c==10){c=0;ev
Candidate:	keycode=13;}else{if(c==13
Candidate:	keychar(evt);break;}retur
Candidate:	keydown:function(evt){var
Candidate:	keypress;if(!kp||!kp._lis
Candidate:	keycode;var _250=(k!=13)&
Candidate:	key){var c=(_250?0:k);if(
Candidate:	key){if(k==3||k==13){retu
Candidate:	key)&&(c>=65&&c<=90)){c+=
Candidate:	keypress",faux:true,charc
Candidate:	keycode(evt,faux.keycode)
Candidate:	keycode);}},_stoppropagat
Candidate:	keycode=this.keycode;if(t
Candidate:	keycode;if(this.ctrlkey){
Candidate:	key){_trysetkeycode(this,
Candidate:	keycode(this,0);}this.ret
Candidate:	keychar(faux);faux.preven
Candidate:	keypress":var c=evt.which
Candidate:	key)?0:c);if((evt.ctrlkey
Candidate:	key)&&(!evt.shiftkey)&&(c
Candidate:	key)&&(c>=65)&&(c<=90)){c
Candidate:	keypress":var c=evt.charc
Candidate:	key,k=evt.keycode;k=k||_2
Candidate:	keycode;k=k||_25f[evt.key
Candidate:	keyidentifier]||0;if(evt.
Candidate:	keyidentifier=="enter"){c
Candidate:	key)&&(c>0)&&(c<27)){c+=9
Candidate:	keys.shift_tab){c=dojo.ke
Candidate:	keys.tab;s=true;}else{c=(
Candidate:	key:s,keycode:k});}return
Candidate:	keycode:k});}return evt;}
Candidate:	keys,{shift_tab:25,up_arr
Candidate:	keys,_25f={"up":dk.up_arr
Candidate:	keydown","keyup","keypres
Candidate:	keyup","keypress"],functi
Candidate:	keypress"],function(evt){
Candidate:	key:"|=",match:function(a
Candidate:	key:"~=",match:function(a
Candidate:	key:"^=",match:function(a
Candidate:	key:"*=",match:function(a
Candidate:	key:"$=",match:function(a
Candidate:	key:"!=",match:function(a
Candidate:	key:"=",match:function(at
Candidate:	key);if(tci>=0){var attr=
Candidate:	key.length);if((_3aa.char
Candidate:	key:"|=",match:function(a
Candidate:	key:"^=",match:function(a
Candidate:	key:"*=",match:function(a
Candidate:	key:"~=",match:function(a
Candidate:	key:"$=",match:function(a
Candidate:	key:"!=",match:function(a
Candidate:	key:"=",match:function(at
Candidate:	key:"first-child",match:f
Candidate:	key:"last-child",match:fu
Candidate:	key:"empty",match:functio
Candidate:	key:"contains",match:func
Candidate:	key:"not",match:function(
Candidate:	key:"nth-child",match:fun
Candidate:	key==_43b){_436=ta.match(
Candidate:	password=r[4]||n;this.hos
Candidate:	password?args.password:un
Candidate:	password:undefined));if(a
Candidate:	keyup",this.heightupdate.
Candidate:	keys' code adapted from m
Candidate:	keys(key) {
	if (!key) {

Candidate:	key) {
	if (!key) {
		key
Candidate:	key) {
		key = event;
		k
Candidate:	key = event;
		key.which 
Candidate:	key.which = key.keycode;

Candidate:	key.keycode;
	}
	if (key.
Candidate:	keycode;
	}
	if (key.whic
Candidate:	key.which == 84) {
		togg
Candidate:	key.which) {
			case 10: 
Candidate:	key.target && isparentors
Candidate:	key.target, 'controls')) 
Candidate:	key
			case 40: // downke
Candidate:	key
				if(number != unde
Candidate:	key
			case 38: // upkey

Candidate:	key
				if(number != unde
Candidate:	key.which < 48 || key.whi
Candidate:	key.which > 57) {
			numb
Candidate:	key.target && isparentors
Candidate:	key.target, 'controls')) 
Candidate:	key.which - 48);
		}
	}
	
Candidate:	key="t" id="toggle" href=
Candidate:	key="z" id="prev" href="j
Candidate:	key="x" id="next" href="j
Candidate:	key trap fix, new functio
Candidate:	keycode;
	}
	try {
		modi
Candidate:	key = e.ctrlkey || e.altk
Candidate:	key || e.altkey || e.meta
Candidate:	key || e.metakey;
	}
	cat
Candidate:	key;
	}
	catch(e) {
		mod
Candidate:	key = false;
	}
	return m
Candidate:	key || e.which == 0;
}

f
Candidate:	keyup = keys;
		document.
Candidate:	keys;
		document.onkeypre
Candidate:	keypress = trap;
		docume
Candidate:	secret=mhybipwos9rcawnwte
Candidate:	api_key=aizasyaxnbq81uhyg
Candidate:	api_key=9e933811a63a4a5d1
Candidate:	api_key=quwm7pd4cv7du89rr
Candidate:	key=802a1e81b3fd9a6dde495
Candidate:	key=aizasyaxnbq81uhygt-dh
Candidate:	key=aizasydvv-zulmveqnf82
Candidate:	key=9e933811a63a4a5d1b53e
Candidate:	key=quwm7pd4cv7du89rr98h9
Candidate:	oauth2_client_id=81767978
Candidate:	oauth2_client_secret=mhyb
Candidate:	oauth2_api_key=aizasyaxnb
Candidate:	password]

Candidate:	apis, you may want to use
Candidate:	token

	protect_from_forg
Candidate:	password])
      @categor
Candidate:	key: '_as_session'

Candidate:	password])
      session[
Candidate:	password, :password_confi
Candidate:	password_confirmation)
  
Candidate:	keys(this._events);for(o=
Candidate:	keys","values","pairs","i
Candidate:	keys(this.routes);while((
Candidate:	api_client'
# # the oauth
Candidate:	api-ruby-client.googlecod
Candidate:	apis.com/auth/youtube'
# 
Candidate:	api_service_name = 'youtu
Candidate:	api_version = 'v3'

# cli
Candidate:	apiclient.new
# youtube =
Candidate:	api(youtube_api_service_n
Candidate:	api_service_name, youtube
Candidate:	api_version)

# auth_util
Candidate:	api's youtube.subscriptio
Candidate:	api_method => youtube.sub
Candidate:	apiclient::clienterror =>
Candidate:	api's videos.insert metho
Candidate:	api_client'
# # the oauth
Candidate:	api-ruby-client.googlecod
Candidate:	apis.com/auth/youtube.upl
Candidate:	api_service_name = 'youtu
Candidate:	api_version = 'v3'

# cli
Candidate:	apiclient.new(:applicatio
Candidate:	api(youtube_api_service_n
Candidate:	api_service_name, youtube
Candidate:	api_version)

# auth_util
Candidate:	api's videos.insert metho
Candidate:	api_method => youtube.vid
Candidate:	apiclient::uploadio.new(o
Candidate:	keys.join(',')
#     },
#
Candidate:	keywords, 'video keywords
Candidate:	keywords, comma-separated
Candidate:	keywords].split(','),
#  
Candidate:	keys.join(',')
#   }
# )

Candidate:	oauth/oauth_util code is 
Candidate:	oauth_util code is not pa
Candidate:	oauth/oauth_util.rb
# req
Candidate:	oauth_util.rb
# require '
Candidate:	oauth/oauth_util'


# # t
Candidate:	oauth_util'


# # this oa
Candidate:	oauth 2.0 access scope al
Candidate:	oauthhelper.new(youtube_s
Candidate:	oauth/oauth_util code is 
Candidate:	oauth_util code is not pa
Candidate:	oauth/oauth_util.rb
# req
Candidate:	oauth_util.rb
# require '
Candidate:	oauth/oauth_util'
# requi
Candidate:	oauth_util'
# require 'tr
Candidate:	oauth 2.0 access scope al
Candidate:	oauthhelper.new(youtube_r
Candidate:	keydown."+e);d.unbind("."
Candidate:	keydown."+e,function(a){2
Candidate:	apis, you may want to use
Candidate:	api.worldweatheronline.co
Candidate:	api');
            }
    
Candidate:	key=h8dtfkhry55kdzesyj9r5
Candidate:	token = getcookie('csrfto
Candidate:	token');

    function cs
Candidate:	token", csrftoken);
     
Candidate:	token);
            }
   
Candidate:	keys,w=i.bind,j=function(
Candidate:	keys(n);i=a.length}if(a(n
Candidate:	keys(n).length},j.first=j
Candidate:	keys=_||function(n){if(n!
Candidate:	keys(i.escape).join("")+"
Candidate:	keys(i.unescape).join("|"
Candidate:	passwordsignupfields: 'us
Candidate:	api.com/calls/url/urlgetr
Candidate:	apikey=' + env['alchemy_k
Candidate:	api.key = env['alchemy_ke
Candidate:	api.search(:concept_taggi
Candidate:	apis.com/freebase/v1/topi
Candidate:	key=' + env['alchemy_key'
Candidate:	key'] + '&url=' + url + '
Candidate:	keywords = json.parse(res
Candidate:	keywords
    keywords_arr
Candidate:	keywords_array = keywords
Candidate:	keywords["concepts"].map 
Candidate:	keywords_array
  end

  d
Candidate:	keywords_array = []
     
Candidate:	key = env['alchemy_key']

Candidate:	key']
      alchemyapi.se
Candidate:	key|
      keywords_array
Candidate:	keywords_array << key["te
Candidate:	key["text"]
    end
    k
Candidate:	keywords_array
  end

  d
Candidate:	key=' + env['freebase']
 
Candidate:	key in options){
				var 
Candidate:	key];
				if(defaults[key
Candidate:	key]){
					that.settings
Candidate:	key] = options[key];
				
Candidate:	key];
				}
			}
		}
	})(
Candidate:	api_client'
  require 'tr
Candidate:	api_name = "youtube"
    
Candidate:	api_version = "v3"
    op
Candidate:	apiclient.new(:key => env
Candidate:	api(youtube_service_api_n
Candidate:	api_name, youtube_api_ver
Candidate:	api_version)
    opts[:pa
Candidate:	api_method => youtube.sea
Candidate:	api.coursera.org/api/cata
Candidate:	api/catalog.v1/courses?q=
Candidate:	api.nytimes.com/svc/searc
Candidate:	api-key=#{env['ny_times_a
Candidate:	api_key']}"
    url =  ur
Candidate:	api.ted.com/v1/search.jso
Candidate:	api-key=" + env['ted_api_
Candidate:	api_key']
    url = uri.e
Candidate:	api.pearson.com/v2/ft/art
Candidate:	apikey=' + env['financial
Candidate:	api.com/calls/url/urlgetc
Candidate:	apikey='+ env['alchemy_ke
Candidate:	api.com/calls/url/urlgetc
Candidate:	apikey='+ env['alchemy_ke
Candidate:	key => env['youtube_devel
Candidate:	key'],
     :authorizatio
Candidate:	key=#{env['ny_times_api_k
Candidate:	key']}"
    url =  uri.en
Candidate:	key=" + env['ted_api_key'
Candidate:	key']
    url = uri.encod
Candidate:	key=' + env['financial_ti
Candidate:	key='+ env['alchemy_key']
Candidate:	key'] +'&url=' + url + '&
Candidate:	key='+ env['alchemy_key']
Candidate:	key'] +'&url=' + url + '&
Candidate:	password: ''
};
Candidate:	password

end

Candidate:	api/1.0/user/repositories
Candidate:	api/1.0/repositories/fres
Candidate:	password + '@bitbucket.or
Candidate:	password + '@bitbucket.or
Candidate:	keys
    var post = _.ext
Candidate:	keydown."+e);d.unbind("."
Candidate:	keydown."+e,function(a){2
Candidate:	keywords": ["framework", 
Candidate:	key:generate"
		]
	},
	"c
Candidate:	token = getcookie('csrfto
Candidate:	token');

    function cs
Candidate:	token", csrftoken);
     
Candidate:	token);
            }
   
Candidate:	secret: '0792f73ab7ed8106
Candidate:	key: 'cebaa7d797f392fa70c
Candidate:	password]

Candidate:	secret in his bosom. he k
Candidate:	api = hyperclient.new('ht
Candidate:	api.artsy.net/api').tap d
Candidate:	api').tap do |api|
  api.
Candidate:	api|
  api.headers.update
Candidate:	api.headers.update('accep
Candidate:	api.headers.update('x-xap
Candidate:	api.nytimes.com/svc/searc
Candidate:	api-key=nytimekey")
     
Candidate:	api.artist(id: artistid)

Candidate:	api.artwork(id: artworkid
Candidate:	token = 'artsy app token'
Candidate:	token'

api = hyperclient
Candidate:	token' => xapp_token)
end
Candidate:	token)
end

def convurl(u
Candidate:	key=nytimekey")
      res
Candidate:	key")
      response = ht
Candidate:	key: '_discoveree_session
Candidate:	password_digest"
    t.da
Candidate:	password: "shuffshuff") #
Candidate:	password_confirmation: "s
Candidate:	api/scan/user',
        t
Candidate:	keybindings require three
Candidate:	keystroke and the command
Candidate:	keybinding which register
Candidate:	keymaps

Candidate:	password]

Candidate:	api/v1/scan/user',
      
Candidate:	api = hypercl", "update('
Candidate:	token=\"+user.access_toke
Candidate:	token);\n    friends."], 
Candidate:	token = success.authrespo
Candidate:	token", "picture?access_t
Candidate:	token=\"+success.authresp
Candidate:	token", "friends?access_t
Candidate:	token=\"+authuser.access_
Candidate:	token);\n        "], "fil
Candidate:	token=\"+$scope.user.acce
Candidate:	token);\n  // "], "file":
Candidate:	token = getcookie('csrfto
Candidate:	token');\n\n    fun"], "f
Candidate:	token = getcookie('csrfto
Candidate:	token');\n\n    fun"], "f
Candidate:	token = 'artsy app token'
Candidate:	token'\n\napi = hypercl",
Candidate:	token' => xapp_token)\nen
Candidate:	token)\nend\n\ndef convur
Candidate:	token=c34fc9f716801846f1d
Candidate:	token=c34fc9f716801846f1d
Candidate:	token = social.extra_data
Candidate:	token'", "b')\n    access
Candidate:	token = social.extra_data
Candidate:	token'"], "file": "keycom
Candidate:	token=c34fc9f716801846f1d
Candidate:	token=c34fc9f716801846f1d
Candidate:	token = keys['twilio_auth
Candidate:	token']\n\texcep", "excep
Candidate:	token = \"\"\n\n\ttry:\n\
Candidate:	token = \"4e9d3571e0828ee
Candidate:	token\t\t= \"432175593-qb
Candidate:	key.length; j++){
       
Candidate:	key[j]);
                
Candidate:	key[j] + '</p><br><br>') 
Candidate:	key": ["friends?access_to
Candidate:	key": ["uthuser.access_to
Candidate:	key": ["friends?access_to
Candidate:	key": [" }\n    var csrft
Candidate:	key": [" }\n    var csrft
Candidate:	key": ["7'\n\t}\n\n]\n\nx
Candidate:	keyartsypull.rb"}, {"key"
Candidate:	key": ["\"/repos?access_t
Candidate:	keycommit/key/helpers.py"
Candidate:	key/helpers.py"}, {"key":
Candidate:	key": ["#     # access_to
Candidate:	keycommit/key/views.py"},
Candidate:	key/views.py"}, {"key": [
Candidate:	key": ["\"/repos?access_t
Candidate:	key_finder.py"}, {"key": 
Candidate:	key": ["\"\n\ttry:\n\t\ta
Candidate:	keys['twilio_auth_token']
Candidate:	keys["], "file": "smartkn
Candidate:	key": ["a7a2e418\"\nauth_
Candidate:	key": ["ujihhu\"\naccess_
Candidate:	api: {

        // api fi
Candidate:	api files to watch:
     
Candidate:	api/**/*']
      },
     
Candidate:	api files are changed:
  
Candidate:	secret the oauth consumer
Candidate:	secret.
 * @param {string
Candidate:	secret, oauth_scope, opt_
Candidate:	secret = consumer_secret;
Candidate:	secret;
  this.oauth_scop
Candidate:	secret = "oauth_token_sec
Candidate:	secret";
  this.callback_
Candidate:	secret" {string} oauth co
Candidate:	secret.
 *         "scope
Candidate:	secret {string} the oauth
Candidate:	secret.
 */
chromeexoauth
Candidate:	secret());
  } else {
   
Candidate:	secret) {
      callback(
Candidate:	secret);
    };
    chrom
Candidate:	secret + encodeuri(this.o
Candidate:	secret = this.gettokensec
Candidate:	secret();
  if (!token ||
Candidate:	secret) {
    throw new e
Candidate:	secret");
  }

  var para
Candidate:	secret : this.consumer_se
Candidate:	secret,
      oauth_secre
Candidate:	secret : secret,
      oa
Candidate:	secret,
      oauth_token
Candidate:	secret = this.gettokensec
Candidate:	secret();
  if (!token ||
Candidate:	secret) {
    throw new e
Candidate:	secret");
  }

  var para
Candidate:	secret : this.consumer_se
Candidate:	secret,
      oauth_secre
Candidate:	secret : secret,
      oa
Candidate:	secret,
      oauth_token
Candidate:	secret" {string} oauth co
Candidate:	secret.
 *         "scope
Candidate:	secret'],
    oauth_confi
Candidate:	secret) {
    background_
Candidate:	secret);
    background_p
Candidate:	secret for the configured
Candidate:	secret the secret to stor
Candidate:	secret to store.
 */
chro
Candidate:	secret = function(secret)
Candidate:	secret) {
  localstorage[
Candidate:	secret + encodeuri(this.o
Candidate:	secret;
};

/**
 * retrie
Candidate:	secret for the configured
Candidate:	secret.
 */
chromeexoauth
Candidate:	secret = function() {
  r
Candidate:	secret + encodeuri(this.o
Candidate:	secret {string} the oauth
Candidate:	secret.
 */
chromeexoauth
Candidate:	secret());
  }
};

/**
 *
Candidate:	secret : this.consumer_se
Candidate:	secret
    }
  });
  var 
Candidate:	secret for later use and 
Candidate:	secret(params['oauth_toke
Candidate:	secret']);
      var url 
Candidate:	secret {string} the oauth
Candidate:	secret.
 */
chromeexoauth
Candidate:	secret : this.consumer_se
Candidate:	secret,
        oauth_sec
Candidate:	secret : this.gettokensec
Candidate:	secret(this.oauth_scope)

Candidate:	secret for later use and 
Candidate:	secret {string} the oauth
Candidate:	secret.
 * @param {xmlhtt
Candidate:	secret = params["oauth_to
Candidate:	secret"];
      this.sett
Candidate:	secret(secret);
      bg.
Candidate:	secret);
      bg.chromee
Candidate:	secret);
    } else {
   
Candidate:	api methods
 * call these
Candidate:	apis/accounts/docs/oauth_
Candidate:	api.  you must call this

Candidate:	api.
 */
chromeexoauth.pr
Candidate:	api.
 * @return {boolean}
Candidate:	api methods
 * used by th
Candidate:	apis/accounts/docs/oauth_
Candidate:	token the oauth request t
Candidate:	token url.
 * @param {str
Candidate:	token the oauth authorize
Candidate:	token url.
 * @param {str
Candidate:	token the oauth access to
Candidate:	token url.
 * @param {str
Candidate:	token, url_auth_token, ur
Candidate:	token, url_access_token,

Candidate:	token,
                  
Candidate:	token = url_request_token
Candidate:	token;
  this.url_auth_to
Candidate:	token = url_auth_token;
 
Candidate:	token;
  this.url_access_
Candidate:	token = url_access_token;
Candidate:	token;
  this.consumer_ke
Candidate:	token = "oauth_token";
  
Candidate:	token";
  this.key_token_
Candidate:	token_secret = "oauth_tok
Candidate:	token_secret";
  this.cal
Candidate:	token url.
 *         "au
Candidate:	token url.
 *         "ac
Candidate:	token url.
 *         "co
Candidate:	token url.  for an exampl
Candidate:	token has
 *     been obt
Candidate:	token {string} the oauth 
Candidate:	token.
 *         secret 
Candidate:	token secret.
 */
chromee
Candidate:	token()) {
    callback(t
Candidate:	token(), this.gettokensec
Candidate:	tokensecret());
  } else 
Candidate:	token, secret) {
      ca
Candidate:	token, secret);
    };
  
Candidate:	tokens stored for this co
Candidate:	tokens = function() {
  d
Candidate:	token + encodeuri(this.oa
Candidate:	token_secret + encodeuri(
Candidate:	token is currently stored
Candidate:	token exists.
 */
chromee
Candidate:	token = function() {
  re
Candidate:	token();
};

/**
 * makes
Candidate:	tokens.
 * @param {string
Candidate:	token = this.gettoken();

Candidate:	token();
  var secret = t
Candidate:	tokensecret();
  if (!tok
Candidate:	token || !secret) {
    t
Candidate:	token or token secret");

Candidate:	token secret");
  }

  va
Candidate:	token: token
    }
  });

Candidate:	token
    }
  });

  retu
Candidate:	token = this.gettoken();

Candidate:	token();
  var secret = t
Candidate:	tokensecret();
  if (!tok
Candidate:	token || !secret) {
    t
Candidate:	token or token secret");

Candidate:	token secret");
  }

  va
Candidate:	token: token
    }
  });

Candidate:	token
    }
  });
};

/**
Candidate:	token url.
 *         "au
Candidate:	token url.
 *         "ac
Candidate:	token url.
 *         "co
Candidate:	token url.  for an exampl
Candidate:	token is obtained, this f
Candidate:	token, secret) {
    back
Candidate:	token, secret);
    backg
Candidate:	token for the configured 
Candidate:	token the token to store.
Candidate:	token to store.
 */
chrom
Candidate:	token = function(token) {
Candidate:	token) {
  localstorage[t
Candidate:	token + encodeuri(this.oa
Candidate:	token;
};

/**
 * retriev
Candidate:	token for the configured 
Candidate:	token.
 */
chromeexoauth.
Candidate:	token = function() {
  re
Candidate:	token + encodeuri(this.oa
Candidate:	token secret for the conf
Candidate:	tokensecret = function(se
Candidate:	token_secret + encodeuri(
Candidate:	tokensecret = function() 
Candidate:	token_secret + encodeuri(
Candidate:	token exists,
 * no redir
Candidate:	token.  if no token exist
Candidate:	token exists and no redir
Candidate:	token is requested and th
Candidate:	token {string} the oauth 
Candidate:	token.
 *         secret 
Candidate:	token secret.
 */
chromee
Candidate:	token()) {
    var params
Candidate:	token = params['oauth_tok
Candidate:	token'];
      var oauth_
Candidate:	token(oauth_token, oauth_
Candidate:	token, oauth_verifier, ca
Candidate:	token(function(url) {
   
Candidate:	token(), this.gettokensec
Candidate:	tokensecret());
  }
};

/
Candidate:	token.
 * @param {functio
Candidate:	token.
 * @param {object}
Candidate:	token = function(callback
Candidate:	token,
    parameters: {

Candidate:	token = chromeexoauth.bin
Candidate:	token, this, callback);
 
Candidate:	token);
};

/**
 * called
Candidate:	token has been returned. 
Candidate:	token
 * secret for later
Candidate:	token.
 * @param {xmlhttp
Candidate:	token.
 */
chromeexoauth.
Candidate:	token = function(callback
Candidate:	token = params['oauth_tok
Candidate:	token'];
      this.setto
Candidate:	tokensecret(params['oauth
Candidate:	token_secret']);
      va
Candidate:	token,
                  
Candidate:	token", token);
      for
Candidate:	token);
      for (var ke
Candidate:	token failed. status " + 
Candidate:	token.
 * @param {string}
Candidate:	token the oauth request t
Candidate:	token.
 * @param {string}
Candidate:	token verifier.
 * @param
Candidate:	token is obtained.
 *    
Candidate:	token {string} the oauth 
Candidate:	token.
 *         secret 
Candidate:	token secret.
 */
chromee
Candidate:	token = function(oauth_to
Candidate:	token, oauth_verifier,
  
Candidate:	token,
      parameters: 
Candidate:	token" : oauth_token,
   
Candidate:	token,
        "oauth_ver
Candidate:	tokensecret(this.oauth_sc
Candidate:	token = chromeexoauth.bin
Candidate:	token, this, callback);
 
Candidate:	token);
  }
};

/**
 * ca
Candidate:	token has been returned. 
Candidate:	token and
 * access token
Candidate:	token secret for later us
Candidate:	token is obtained.
 *    
Candidate:	token {string} the oauth 
Candidate:	token.
 *         secret 
Candidate:	token secret.
 * @param {
Candidate:	token.
 */
chromeexoauth.
Candidate:	token = function(callback
Candidate:	token = params["oauth_tok
Candidate:	token"];
      var secret
Candidate:	token_secret"];
      thi
Candidate:	token(token);
      this.
Candidate:	token);
      this.settok
Candidate:	tokensecret(secret);
    
Candidate:	token, secret);
    } els
Candidate:	token failed with status 
Candidate:	key the oauth consumer ke
Candidate:	key.
 * @param {string} c
Candidate:	key, consumer_secret, oau
Candidate:	key = consumer_key;
  thi
Candidate:	key;
  this.consumer_secr
Candidate:	key_token = "oauth_token"
Candidate:	key_token_secret = "oauth
Candidate:	key in opt_args['auth_par
Candidate:	key)) {
        this.auth
Candidate:	key] = opt_args['auth_par
Candidate:	key];
      }
    }
  }
}
Candidate:	key" {string} oauth consu
Candidate:	key.
 *         "consumer
Candidate:	key_token + encodeuri(thi
Candidate:	key_token_secret + encode
Candidate:	key : this.consumer_key,

Candidate:	key,
      shared_secret 
Candidate:	key : this.consumer_key,

Candidate:	key,
      shared_secret 
Candidate:	key" {string} oauth consu
Candidate:	key.
 *         "consumer
Candidate:	key'],
    oauth_config['
Candidate:	key/value format.
 * @par
Candidate:	key/value pairs.
 * @para
Candidate:	key/value pairs found
 * 
Candidate:	keyval = param.split("=")
Candidate:	keyval.length == 2) {
   
Candidate:	key = chromeexoauth.fromr
Candidate:	keyval[0]);
      var val
Candidate:	keyval[1]);
      decoded
Candidate:	key] = val;
    }
  }
  r
Candidate:	key/value pairs.
 * @retu
Candidate:	key/value pairs found in 
Candidate:	key/value parameter to th
Candidate:	key a key
 * @param {stri
Candidate:	key
 * @param {string} va
Candidate:	key and value
 *     appe
Candidate:	key, value) {
  var sep =
Candidate:	key) + "=" + chromeexoaut
Candidate:	key_token + encodeuri(thi
Candidate:	key_token + encodeuri(thi
Candidate:	key_token_secret + encode
Candidate:	key_token_secret + encode
Candidate:	key : this.consumer_key,

Candidate:	key,
      shared_secret 
Candidate:	key in this.auth_params) 
Candidate:	key)) {
          url = c
Candidate:	key, this.auth_params[key
Candidate:	key]);
        }
      }

Candidate:	key : this.consumer_key,

Candidate:	key,
        shared_secre
Candidate:	oauth request token url.

Candidate:	oauth authorize token url
Candidate:	oauth access token url.
 
Candidate:	oauth consumer key.
 * @p
Candidate:	oauth consumer secret.
 *
Candidate:	oauth_scope the oauth sco
Candidate:	oauth scope parameter.
 *
Candidate:	oauth.html, the name
 *  
Candidate:	oauth(url_request_token, 
Candidate:	oauth_scope, opt_args) {

Candidate:	oauth_scope = oauth_scope
Candidate:	oauth_scope;
  this.app_n
Candidate:	oauth library";
  this.ke
Candidate:	oauth_token";
  this.key_
Candidate:	oauth_token_secret";
  th
Candidate:	oauth.html";
  this.auth_
Candidate:	oauth helper from the bac
Candidate:	oauth calls.
 * @param {o
Candidate:	oauth_config configuratio
Candidate:	oauth request token url.

Candidate:	oauth authorize token url
Candidate:	oauth access token url.
 
Candidate:	oauth consumer key.
 *   
Candidate:	oauth consumer secret.
 *
Candidate:	oauth access scope.
 *   
Candidate:	oauth_ref.html#getauth
 *
Candidate:	oauth} an initialized chr
Candidate:	oauth object.
 */
chromee
Candidate:	oauth.initbackgroundpage 
Candidate:	oauth_config) {
  window.
Candidate:	oauthconfig = oauth_confi
Candidate:	oauth_config;
  window.ch
Candidate:	oauth = chromeexoauth.fro
Candidate:	oauth.fromconfig(oauth_co
Candidate:	oauth_config);
  window.c
Candidate:	oauthredirectstarted = fa
Candidate:	oauthrequestingaccess = f
Candidate:	oauth.callback_page);
  v
Candidate:	oauthrequestingaccess == 
Candidate:	oauth;
};

/**
 * authori
Candidate:	oauth access token.
 *   
Candidate:	oauth access token secret
Candidate:	oauth.prototype.authorize
Candidate:	oauthonauthorize = functi
Candidate:	oauth tokens stored for t
Candidate:	oauth api.
 */
chromeexoa
Candidate:	oauth.prototype.cleartoke
Candidate:	oauth_scope)];
  delete l
Candidate:	oauth_scope)];
};

/**
 *
Candidate:	oauth api.
 * @return {bo
Candidate:	oauth.prototype.hastoken 
Candidate:	oauth-signed http request
Candidate:	oauth.prototype.sendsigne
Candidate:	oauth.sendrequest(method,
Candidate:	oauth parameters to the g
Candidate:	oauth params.
 */
chromee
Candidate:	oauth.prototype.signurl =
Candidate:	oauth token or token secr
Candidate:	oauthsimple().sign({
    
Candidate:	oauth_secret : secret,
  
Candidate:	oauth_token: token
    }

Candidate:	oauth parameters.
 * @par
Candidate:	oauth_* params.
 */
chrom
Candidate:	oauth.prototype.getauthor
Candidate:	oauth token or token secr
Candidate:	oauthsimple().getheaderst
Candidate:	oauth_secret : secret,
  
Candidate:	oauth_token: token
    }

Candidate:	oauth object from the sup
Candidate:	oauth_config configuratio
Candidate:	oauth request token url.

Candidate:	oauth authorize token url
Candidate:	oauth access token url.
 
Candidate:	oauth consumer key.
 *   
Candidate:	oauth consumer secret.
 *
Candidate:	oauth access scope.
 *   
Candidate:	oauth_ref.html#getauth
 *
Candidate:	oauth} an initialized chr
Candidate:	oauth object.
 */
chromee
Candidate:	oauth.fromconfig = functi
Candidate:	oauth_config) {
  return 
Candidate:	oauth(
    oauth_config['
Candidate:	oauth_config['request_url
Candidate:	oauth_config['authorize_u
Candidate:	oauth_config['access_url'
Candidate:	oauth_config['consumer_ke
Candidate:	oauth_config['consumer_se
Candidate:	oauth_config['scope'],
  
Candidate:	oauth_config['app_name'],
Candidate:	oauth_config['auth_params
Candidate:	oauth.html and redirects 
Candidate:	oauth flow.  once an acce
Candidate:	oauth.html.
 */
chromeexo
Candidate:	oauth.initcallbackpage = 
Candidate:	oauth_config = background
Candidate:	oauthconfig;
  var oauth 
Candidate:	oauth = chromeexoauth.fro
Candidate:	oauth.fromconfig(oauth_co
Candidate:	oauth_config);
  backgrou
Candidate:	oauthredirectstarted = tr
Candidate:	oauth.initoauthflow(funct
Candidate:	oauthflow(function (token
Candidate:	oauthonauthorize(token, s
Candidate:	oauthredirectstarted = fa
Candidate:	oauth.sendrequest = funct
Candidate:	oauth.formdecode = functi
Candidate:	oauth.fromrfc3986(keyval[
Candidate:	oauth.fromrfc3986(keyval[
Candidate:	oauth.getquerystringparam
Candidate:	oauth.formdecode(querystr
Candidate:	oauth.bind = function(fun
Candidate:	oauth.torfc3986 = functio
Candidate:	oauth.fromrfc3986 = funct
Candidate:	oauth.addurlparam = funct
Candidate:	oauth.torfc3986(key) + "=
Candidate:	oauth.torfc3986(value);
}
Candidate:	oauth token for the confi
Candidate:	oauth.prototype.settoken 
Candidate:	oauth_scope)] = token;
};
Candidate:	oauth.prototype.gettoken 
Candidate:	oauth_scope)];
};

/**
 *
Candidate:	oauth token secret for th
Candidate:	oauth.prototype.settokens
Candidate:	oauth_scope)] = secret;
}
Candidate:	oauth.prototype.gettokens
Candidate:	oauth_scope)];
};

/**
 *
Candidate:	oauth authorization flow 
Candidate:	oauth parameters from the
Candidate:	oauth access token.
 *   
Candidate:	oauth access token secret
Candidate:	oauth.prototype.initoauth
Candidate:	oauthflow = function(call
Candidate:	oauth.getquerystringparam
Candidate:	oauthcallback'] == 'true'
Candidate:	oauth_token = params['oau
Candidate:	oauth_token'];
      var 
Candidate:	oauth_verifier = params['
Candidate:	oauth_verifier']
      th
Candidate:	oauth_token, oauth_verifi
Candidate:	oauth_verifier, callback)
Candidate:	oauthcallback'
      }
  
Candidate:	oauth request token.
 * @
Candidate:	oauth provider will redir
Candidate:	oauth.prototype.getreques
Candidate:	oauthcallback";
  var url
Candidate:	oauth.addurlparam(url, ur
Candidate:	oauthsimple().sign({
    
Candidate:	oauth_displayname" : this
Candidate:	oauth_scope,
      "oauth
Candidate:	oauth_callback" : url_cal
Candidate:	oauth.bind(this.onrequest
Candidate:	oauth.sendrequest("get", 
Candidate:	oauth.prototype.onrequest
Candidate:	oauth.formdecode(xhr.resp
Candidate:	oauth_token'];
      this
Candidate:	oauth_token_secret']);
  
Candidate:	oauth.addurlparam(this.ur
Candidate:	oauth_token", token);
   
Candidate:	oauth.addurlparam(url, ke
Candidate:	oauth access token.
 * @p
Candidate:	oauth_token the oauth req
Candidate:	oauth request token.
 * @
Candidate:	oauth_verifier the oauth 
Candidate:	oauth token verifier.
 * 
Candidate:	oauth access token.
 *   
Candidate:	oauth access token secret
Candidate:	oauth.prototype.getaccess
Candidate:	oauth_token, oauth_verifi
Candidate:	oauth_verifier,
         
Candidate:	oauthrequestingaccess == 
Candidate:	oauthrequestingaccess = t
Candidate:	oauthsimple().sign({
    
Candidate:	oauth_token" : oauth_toke
Candidate:	oauth_token,
        "oau
Candidate:	oauth_verifier" : oauth_v
Candidate:	oauth_verifier
      },
 
Candidate:	oauth_secret : this.getto
Candidate:	oauth_scope)
      }
    
Candidate:	oauth.bind(this.onaccesst
Candidate:	oauth.sendrequest("get", 
Candidate:	oauth access token.
 *   
Candidate:	oauth access token secret
Candidate:	oauth.prototype.onaccesst
Candidate:	oauth.formdecode(xhr.resp
Candidate:	oauth_token"];
      var 
Candidate:	oauth_token_secret"];
   
Candidate:	oauthrequestingaccess = f
Candidate:	oauthrequestingaccess = f
Candidate:	secret is the shared secr
Candidate:	secret (duh).
     *
    
Candidate:	secret are generally prov
Candidate:	secrets() or as an argume
Candidate:	secret:'xyz-5309'
       
Candidate:	secret (string) the share
Candidate:	secret. this value is als
Candidate:	secret)
    {
/*        i
Candidate:	secret == undefined)
    
Candidate:	secret (shared secret) fo
Candidate:	secret) for oauthsimple. 
Candidate:	secrets={};
        this.
Candidate:	secrets['consumer_key'] =
Candidate:	secret !== undefined) {
 
Candidate:	secrets['shared_secret'] 
Candidate:	secret'] = shared_secret;
Candidate:	secret;
            }
   
Candidate:	secret:, oauth_token: oau
Candidate:	secret:}
         */
    
Candidate:	secrets = function(signat
Candidate:	secrets[i] = signatures[i
Candidate:	secrets['api_key']) {
   
Candidate:	secrets.consumer_key = th
Candidate:	secrets.api_key;
        
Candidate:	secrets['access_token']) 
Candidate:	secrets.oauth_token = thi
Candidate:	secrets.access_token;
   
Candidate:	secrets['access_secret'])
Candidate:	secret']) {
             
Candidate:	secrets.oauth_secret = th
Candidate:	secret = this._secrets.ac
Candidate:	secrets.access_secret;
  
Candidate:	secret;
                }
Candidate:	secrets.consumer_key === 
Candidate:	secrets');
              
Candidate:	secrets.shared_secret ===
Candidate:	secret === undefined) {
 
Candidate:	secret in oauthsimple.set
Candidate:	secrets');
              
Candidate:	secrets.oauth_token !== u
Candidate:	secrets.oauth_secret === 
Candidate:	secret === undefined)) {

Candidate:	secret for supplied oauth
Candidate:	secrets');
              
Candidate:	secrets(args['signatures'
Candidate:	secrets.consumer_key === 
Candidate:	secrets.consumer_key;
   
Candidate:	secrets['oauth_secret'] =
Candidate:	secret'] === undefined) {
Candidate:	secrets['oauth_token'] ==
Candidate:	secrets.oauth_token;
    
Candidate:	secrets.
                
Candidate:	secret/)) {
             
Candidate:	secretkey = this._oauthes
Candidate:	secrets.shared_secret)+'&
Candidate:	secret)+'&'+
            
Candidate:	secrets.oauth_secret);
  
Candidate:	secret);
            if (
Candidate:	secretkey;
            }

Candidate:	secretkey,sigstring);
   
Candidate:	api_key is the api key, a
Candidate:	api key, also known as th
Candidate:	api_key and shared_secret
Candidate:	api_key:'12345abcd',
    
Candidate:	api_key {string}       th
Candidate:	api key (sometimes referr
Candidate:	api_key == undefined)
   
Candidate:	api_key (oauth_consumer_k
Candidate:	apikey();
               
Candidate:	api_key:, shared_secret:,
Candidate:	api_key']) {
            
Candidate:	api_key;
                
Candidate:	apikey = function() {
   
Candidate:	tokens. it does not valid
Candidate:	token. it is for client u
Candidate:	token (sorry, i don't pro
Candidate:	tokensandsecrets() or as 
Candidate:	token'] === undefined) {

Candidate:	token();
                
Candidate:	token/signature pairs {ap
Candidate:	token: oauth_secret:}
   
Candidate:	tokensandsecrets = functi
Candidate:	token']) {
              
Candidate:	token = this._secrets.acc
Candidate:	token;
                }

Candidate:	tokensandsecrets');
     
Candidate:	tokensandsecrets');
     
Candidate:	token !== undefined) && (
Candidate:	token in oauthsimple.sett
Candidate:	tokensandsecrets');
     
Candidate:	tokensandsecrets(args['si
Candidate:	token=element.split('=');
Candidate:	token[1]) {
             
Candidate:	token[1]);
              
Candidate:	token[0]]){
             
Candidate:	token[0]] instanceof arra
Candidate:	token[0]] = array(result[
Candidate:	token[0]],value);
       
Candidate:	token[0]].push(value);
  
Candidate:	token[0]]=value;
        
Candidate:	token = function() {
    
Candidate:	token'] === undefined) {

Candidate:	token (access_token) set 
Candidate:	token) set for oauthsimpl
Candidate:	token'] = this._secrets.o
Candidate:	token;
            return
Candidate:	token;
        };

      
Candidate:	key is the api key, also 
Candidate:	key, also known as the oa
Candidate:	key
     * shared_secret 
Candidate:	key and shared_secret are
Candidate:	key:'12345abcd',
        
Candidate:	key {string}       the ap
Candidate:	key (sometimes referred t
Candidate:	key) this value is usuall
Candidate:	key,shared_secret)
    {

Candidate:	key == undefined)
       
Candidate:	key (oauth_consumer_key) 
Candidate:	key) for oauthsimple. thi
Candidate:	key !== undefined) {
    
Candidate:	key'] = consumer_key;
   
Candidate:	key;
            }
      
Candidate:	key'] === undefined) {
  
Candidate:	key();
                }

Candidate:	key:, shared_secret:, oau
Candidate:	key']) {
                
Candidate:	key = this._secrets.api_k
Candidate:	key;
                }
  
Candidate:	key === undefined) {
    
Candidate:	key in oauthsimple.settok
Candidate:	keytoken=element.split('=
Candidate:	keytoken[1]) {
          
Candidate:	keytoken[1]);
           
Candidate:	keytoken[0]]){
          
Candidate:	keytoken[0]] instanceof a
Candidate:	keytoken[0]] = array(resu
Candidate:	keytoken[0]],value);
    
Candidate:	keytoken[0]].push(value);
Candidate:	keytoken[0]]=value;
     
Candidate:	key = function() {
      
Candidate:	key === undefined) {
    
Candidate:	key set for oauthsimple.'
Candidate:	key']=this._secrets.consu
Candidate:	key;
            return t
Candidate:	key;
        };

        
Candidate:	key = this._oauthescape(t
Candidate:	key;
            }
      
Candidate:	key,sigstring);
         
Candidate:	oauthsimple
  * a simpler
Candidate:	oauth
  *
  * author:    
Candidate:	oauthsimple
  *
  * copyr
Candidate:	oauthsimple;

if (oauthsi
Candidate:	oauthsimple === undefined
Candidate:	oauth
     *
     * this 
Candidate:	oauth elements, it does n
Candidate:	oauth consumer key
     *
Candidate:	oauth services. you need 
Candidate:	oauth without that minima
Candidate:	oauth token (sorry, i don
Candidate:	oauthobject = oauthsimple
Candidate:	oauthsimple().sign({path:
Candidate:	oauthobject.signed_url;
 
Candidate:	oauthsimple creator
     
Candidate:	oauthsimple
     *
     *
Candidate:	oauthsimple = function (c
Candidate:	oauth_consumer_key) for o
Candidate:	oauthsimple. this is usua
Candidate:	oauthsimple. this is usua
Candidate:	oauth_nonce'] === undefin
Candidate:	oauth_timestamp'] === und
Candidate:	oauth_method'] === undefi
Candidate:	oauth_consumer_key'] === 
Candidate:	oauth_token'] === undefin
Candidate:	oauthsimple.seturl');
   
Candidate:	oauthsimple.setaction');

Candidate:	oauth_token: oauth_secret
Candidate:	oauth_secret:}
         *
Candidate:	oauth_token = this._secre
Candidate:	oauth_secret = this._secr
Candidate:	oauthsimple.settokensands
Candidate:	oauthsimple.settokensands
Candidate:	oauth_token !== undefined
Candidate:	oauth_secret === undefine
Candidate:	oauth_secret for supplied
Candidate:	oauth_token in oauthsimpl
Candidate:	oauthsimple.settokensands
Candidate:	oauthsimple.setsignaturem
Candidate:	oauth_signature_method']=
Candidate:	oauth_signature']=this._g
Candidate:	oauthescape(this._paramet
Candidate:	oauth_signature']),
     
Candidate:	oauth_signature'] === und
Candidate:	oauth ';
            for 
Candidate:	oauth/)) {
              
Candidate:	oauthescape(this._paramet
Candidate:	oauthescape(this._paramet
Candidate:	oauthescape = function(st
Candidate:	oauthescape');
          
Candidate:	oauth_nonce']=result;
   
Candidate:	oauthsimple.');
         
Candidate:	oauth_consumer_key']=this
Candidate:	oauth_consumer_key;
     
Candidate:	oauth_secret'] === undefi
Candidate:	oauth_token'] === undefin
Candidate:	oauth_token (access_token
Candidate:	oauthsimple.');
         
Candidate:	oauth_token'] = this._sec
Candidate:	oauth_token;
            
Candidate:	oauth_token;
        };


Candidate:	oauth_timestamp'] = ts;
 
Candidate:	oauthescape(paramname) + 
Candidate:	oauthescape(sorted[j]));

Candidate:	oauthescape(paramname) + 
Candidate:	oauthescape(this._paramet
Candidate:	oauthescape(this._secrets
Candidate:	oauthescape(this._secrets
Candidate:	oauth_secret);
          
Candidate:	oauth_signature_method'] 
Candidate:	oauth_signature_method'] 
Candidate:	oauthescape(this._action)
Candidate:	oauthescape(this._path)+'
Candidate:	oauthescape(this._normali
Candidate:	key: '_depot_session'

Candidate:	password'],function(resul
Candidate:	password = $('#password')
Candidate:	password').val();
       
Candidate:	password': extension_pass
Candidate:	password}, function() {
 
Candidate:	password: extension_passw
Candidate:	password
                
Candidate:	password: result['passwor
Candidate:	password']
              
Candidate:	keyboard
    // for form 
Candidate:	keyboard) {
      cordova
Candidate:	keyboard.hidekeyboardacce
Candidate:	keyboardaccessorybar(true
Candidate:	key, val;
		bert_buf_ensu
Candidate:	key = bert_read(buf);
		v
Candidate:	key, val);
	}

	if (type 
Candidate:	password'],function(resul
Candidate:	password = $('#password')
Candidate:	password').val();
       
Candidate:	password': extension_pass
Candidate:	password}, function() {
 
Candidate:	password: extension_passw
Candidate:	password
                
Candidate:	password: result['passwor
Candidate:	password']
              
Candidate:	apis, you may want to use
Candidate:	api

-spec encode(term())
Candidate:	token

	def index
		@user
Candidate:	password])
			@user.conce
Candidate:	password])
			session[:us
Candidate:	password, :password_confi
Candidate:	password_confirmation)
  
Candidate:	password: 'your_mysql_pas
Candidate:	password',
    database: 
Candidate:	api
 * controlling the mo
Candidate:	api/v2'
    prefix: '',


Candidate:	secret csrf token, which 
Candidate:	tokens are like a trackin
Candidate:	token tells the server "y
Candidate:	token, identified as the 
Candidate:	token, which is refreshed
Candidate:	token has a short-lived e
Candidate:	token` route, where it wi
Candidate:	token in your front-end a
Candidate:	token route to get a vali
Candidate:	token.
 * 
 * for more in
Candidate:	api.com/calls/url/urlgetr
Candidate:	apikey=' + env['alchemy_a
Candidate:	api_key'] + '&url=' + url
Candidate:	key=' + env['alchemy_api_
Candidate:	key'] + '&url=' + url + '
Candidate:	keywords = json.parse(res
Candidate:	keywords_array = keywords
Candidate:	keywords["concepts"].map 
Candidate:	keywords_array[0]
	end

	
Candidate:	api_client'
	require 'tro
Candidate:	api.nytimes.com/svc/searc
Candidate:	api-key=#{env['ny_times_a
Candidate:	api_key']}")
		response =
Candidate:	api.coursera.org/api/cata
Candidate:	api/catalog.v1/courses?q=
Candidate:	api_name = "youtube"
    
Candidate:	api_version = "v3"
    op
Candidate:	apiclient.new(:key => env
Candidate:	api_key'],
     :authoriz
Candidate:	api(youtube_service_api_n
Candidate:	api_name, youtube_api_ver
Candidate:	api_version)
    opts[:pa
Candidate:	api_method => youtube.sea
Candidate:	apis.com/freebase/v1/topi
Candidate:	api_key']
    results = j
Candidate:	key=#{env['ny_times_api_k
Candidate:	key']}")
		response = htt
Candidate:	key => env['google_api_ke
Candidate:	key'],
     :authorizatio
Candidate:	key=' + env['google_api_k
Candidate:	key']
    results = json.
Candidate:	oauth
 *	+ basicauth
 *	+
Candidate:	password

	validates :use
Candidate:	password" type="password"
Candidate:	password"/>
  //			<input
Candidate:	secret is automatically g
Candidate:	secret: 'd7c0441d396e6ea6
Candidate:	password>
  // prefix: 's
Candidate:	password: '',
  // auto_r
Candidate:	password>'



  // match 
Candidate:	api/js?sensor=false'], fu
Candidate:	password]

Candidate:	key: '_web_session'

Candidate:	password_digest"
    t.da
Candidate:	secret, env['session_secr
Candidate:	secret'] || 'this is a se
Candidate:	secret shhhhh'

  # set t
Candidate:	password => db.password,

Candidate:	password,
  :database => 
Candidate:	api

concat(a, b) ->
  a 
Candidate:	tokens(datastring, "\n"),
Candidate:	tokens(line, "\t"),
  ets
Candidate:	tokens, _} = erl_scan:str
Candidate:	tokens),
  {value, result
Candidate:	keysearch/3,keysort/2,key
Candidate:	keysort/2,keydelete/3]).

Candidate:	keydelete/3]).
-import(li
Candidate:	keysort(#nstate.id, nfa2)
Candidate:	keysearch(e, 1, d), e1 en
Candidate:	keysearch(b, 1, d0) of
	{
Candidate:	keysearch(b, #cstate.id, 
Candidate:	keydelete(s, #cstate.id, 
Candidate:	keysearch(b, #cstate.id, 
Candidate:	keysearch(name, 1, data) 
Candidate:	keyreplace(name, 1, data,
Candidate:	key,val}]}
#    [erlang] 
Candidate:	key=>:val}
#    [erlang] 
Candidate:	key=>:val, :ruby=>:true}

Candidate:	key,val},{ruby,true}}}
# 
Candidate:	password, room) ->
  spaw
Candidate:	password, room])),
    po
Candidate:	password, room_name = *ar
Candidate:	password
room = campfire.
Candidate:	apiou\lbl{tl{vgwtjytvgac
Candidate:	apio_unxzdmrt[celtnsyotxx
Candidate:	apiue8\sayt>ne3zh:dqbcy@n
Candidate:	apibpffsexh9ui;qg;\pb]p@l
Candidate:	apiat_sebvh_qf`ogs`yivpsd
Candidate:	api9tr9zh>zh:[jbm;7^mcfyi
Candidate:	apiaf=6i@1xm7eufdpo`nn`rg
Candidate:	apivki<>71e82o>4f3/;+.2)*
Candidate:	api^nnalifqvcsv[nhuh@tebt
Candidate:	api`ogyldynh\mjwjbujdujfw
Candidate:	apifukgwjesiw_up_kfyh]onx
Candidate:	apixg?csc`q>`rebsn]pg_lfb
Candidate:	apidqjaoedwgdygbvffvgivhz
Candidate:	api`og`mielpy<@r92ye<]le-
Candidate:	apicvmd{qezqbvh~q`~ltqu
Candidate:	api9wma[ocasjg[oaxfl\mvap
Candidate:	apihph@yea]}
Candidate:	api{`uoufvxnnhgfe>ucmq`fp
Candidate:	apidskrayn]vl[t\his=2nwez
Candidate:	api6fb=khhld^eia64
Candidate:	apiygcvdbxfdeodgoehlhgkh_
Candidate:	apio\uza\w`pvzd}[?^aso5y
Candidate:	api:s=2lkda<6bd:^c8`c;u:3
Candidate:	api`ogrbijxfljur;5cpjh
Candidate:	apive=l[ko^n]ib`leo=/m;-z
Candidate:	apipc;_zgrcp|bqjtgck?mo
Candidate:	apivgdncvb;zedaspkg>ia6fv
Candidate:	api\mfre?vddvh=vc5n71g:4j
Candidate:	apicohimbq=2[i3ez>gw>kq@f
Candidate:	apicypd\q`pcgoe_maqi<pf<u
Candidate:	apicrhfvhhuh?xjawihk=:sg;
Candidate:	apicle=_ribre]teeym[i?p>2
Candidate:	apisf6k9+k;.9-^m=^lcn=]
Candidate:	apijtiq\ir\gag:ajbxg=]lb\
Candidate:	apiyldzuqtljua@]k?l^amdcx
Candidate:	apiyldxndzmdtc<xc@x?8m<2u
Candidate:	apifunl]htbnn]ijyep^hq`fu
Candidate:	api`omdrpeqlamsfswhsvdln\
Candidate:	apic}mxqgui8zginw<s]:fk-,
Candidate:	apibohjwiq`pcujashgugcve^
Candidate:	api9tt<yvqvmnsjake9ki4mj9
Candidate:	api?p$/;5</7%/
4?:f)
Candidate:	apibfi^jdvietdamb^jcc1#/$
Candidate:	api[qhvlctkbd`tzsmrkevog\
Candidate:	apiyjk[ntcsl[gxfnziw_qq]q
Candidate:	apimfixsujxrwt|gfqk
Candidate:	apiqh9qk5m@8r@6yh6qg;mj7w
Candidate:	apiapi?nj>nl?nl@pkemhdojf
Candidate:	api?nj>nl?nl@pkemhdojfmje
Candidate:	api\nkynlwmlulmzuq]xt`[w^
Candidate:	apibqjcrkcrkbqj`oh^mf\kdy
Candidate:	api^mf^mfcrkixqzj]tcyk]tf
Candidate:	apidslhwpl[tp_xog\|sjx
Candidate:	apibqj\lo]mp_or`ps`ps_or]
Candidate:	apizjk\lm`pqbrsbrs`pq\lmz
Candidate:	apiapiyiiyiiyiiyiiyiiyiiy
Candidate:	apiyiiyiiyiiyiiyiiyiiyiiy
Candidate:	api`oh\kdzib]le`ohwp@yrb]
Candidate:	apicqjdpicmf@ib<rketmgvoi
Candidate:	api@qefkfekhellgnpforfptg
Candidate:	apihyoqatx`s\xmzpfdloemoi
Candidate:	api_ng_vm_vm_vm_vm_vm_vm_
Candidate:	apixg@v\nw]o[]p_]q`yo^ul]
Candidate:	api_ngzqhzqhzqhzqhzqhzqhz
Candidate:	apibqjbqjapi_ng\kd[jc^ula
Candidate:	api_ng\kd[jc^ulaxoe\sh_vi
Candidate:	apia]qa]q`\p_[o^zn]ym\xl\
Candidate:	apierlgrmjrndundunctmark`
Candidate:	apidqkgrmjrnbslbslark`qj`
Candidate:	apidqkfqliqm^oh^oh_pi_pi`
Candidate:	apicpjepkgok[le[le\mf^oh_
Candidate:	api^mf]le\kd]le^mfwnewnex
Candidate:	api\rp\rp\rp\rp\rp\rp\rp\
Candidate:	api\rp\rp\rp\rp\rp\rp\rp\
Candidate:	apifun^na^na_ob^na[k>wg:t
Candidate:	api?of=qg>uh@ri@ri@qh?pg>
Candidate:	api?of=qg>uh@xofwnewnevmd
Candidate:	api]pg]ng^ojarm[lgfwrctm^
Candidate:	apicqmbtqynlbxvtokyvqxup[
Candidate:	apidunpa:sb;uf?tg?na9k>6i
Candidate:	api\kc]lbzh>ua6w@8\e=r>5[
Candidate:	api[jc]nin_xatk]sikbybyrk
Candidate:	apijyrexpzoizqjzqhypixojy
Candidate:	apidqjjvku_r~dwfz}`nft
Candidate:	apii[ptdu}gyycv{hzhy}bqz
Candidate:	api]le_ng`midqkboi`mgcrj]
Candidate:	apibtkexocvmatkcvmbul^qhg
Candidate:	apiser\ntapn\fm]fkyclwds]
Candidate:	api]mqeuviytgwk^ni\lj]mh[
Candidate:	api[nmasbvhgyln^om[mfvghx
Candidate:	apixkcf=4jd8mg;mi>ng?vkew
Candidate:	api\kgzjewjqatugzpbp_i
Candidate:	api\kk^matdh\nj^ph^rf\pdz
Candidate:	api^lcvfscs|l\rbrk^miyihv
Candidate:	apita^l4yg1zg6`m?ak>]e8en
Candidate:	api?qmbsja[leaphfukk_o_xf
Candidate:	api\il_nqarpbs`qr]j|hos^
Candidate:	apiavoeic7fc4kh9hd8><0olc
Candidate:	apive{hwn{hw}j[sco^t
Candidate:	api]m@]m>vixm`oi\lwi<pd6w
Candidate:	apive[n=wfrvfoiveiverzan
Candidate:	apitau`kt_ljwfr@2j:+`m<xg
Candidate:	apixfvi8vf6bq?q^mvdpyhtzi
Candidate:	apitas\jyd~gt\tmv
Candidate:	apivgbqaue6?1$:0&j[hp]r
Candidate:	apixdvalr[s^m[kxits
Candidate:	api<! h4h g
Candidate:	api6sj8b<&|t_gainf/icisl2
Candidate:	apif7<9*;8):7(da2=9-

Candidate:	api6tm[_xhb=*1- .*@<#
Candidate:	keyd^va[r]w=hb:ea;fb@kgcn
Candidate:	keym=rh>kb=oi=b[h_se`oeoa
Candidate:	keysasisfzj=ue6y@;k63si?v
Candidate:	keymdvkaui`vjcwkfukyezl^s
Candidate:	keypg\og]kiwlhsuhstf_qf[l
Candidate:	keyajwfjsahwem`op_mfuc^q@
Candidate:	keyjzzsf@wphynlfmi_g=rd;y
Candidate:	keyldvlcsi@zoi^pm\mjvkewe
Candidate:	keyil_ohzoivrwhkshfaueaz@
Candidate:	keyhapc=md?tf=wd=wf>@5/81
Candidate:	keyc_l=lvhclfy:?wa3[k2]l<
Candidate:	keyofqk=vteoh>qd>rnbpm<ve
Candidate:	keyyr@k@.ra1p=/`ogjzmdubg
Candidate:	keygef74v]<{u_yc/$"m;9l>
Candidate:	keyjupsuuali[qg[rcue8]i@y
Candidate:	keyjcdrnemiamf\ncbvhfuk_o
Candidate:	keypibvhm]n`riqj@qqeokbib
Candidate:	keyhagwgpi6ui;amd_k@]k=]j
Candidate:	keyslbb[ug>?/(-;2561.<1/=
Candidate:	keyjecirnrgs\js[qed;ei;{q
Candidate:	keyrlyyq{xotoiojfvqkql
Candidate:	keyf^\y|uk
Candidate:	keyyr{
Candidate:	keyoftk9yl9yg=na0o?/l9+k7
Candidate:	keyb@n[=\n4uc+^a9c(!:0.)&
Candidate:	keypig@8rj=g^m_veog<b92d5
Candidate:	keybpqml\;c18%e2#?!!h+
Candidate:	keyiploam5vv'n9yj)%(
Candidate:	keyabubyclz^7gwyd3#wgn
Candidate:	keykaoevd8cta{lopn}cjgr?
Candidate:	key?^n>ezd`^epj>k<9o@9vnc
Candidate:	keyihyhlr^eiwcerdiyi>*!t
Candidate:	keyng]piaqlfrkeqifia_dz[[
Candidate:	keybqpz ` a c c \
Candidate:	keykbue^q@oprsssyut_wtcxr
Candidate:	keymbxl\vhwqczpnyomyom\rp
Candidate:	keyrj]jar_sclosnqut[^mn
Candidate:	keyjc[jbqhcpfdmcbkabj?ej?
Candidate:	keykcxawml_vhyrhytiwscqoc
Candidate:	keyjc\kc[g@]hc]hc[hd
Candidate:	keylf_rjxmgxkcwha\ib^fb[b
Candidate:	keyumbsk`vlbvmri{ocsg~
Candidate:	keyiaueexgm`ohxhetdl[km]m
Candidate:	keyii]mj]mi\li[nh[katd`sc
Candidate:	keykexpctmn`wiylaqdfvgfyi
Candidate:	keyco`mixhp]nzgvwfrk_il`j
Candidate:	keyki]mdwfatcgzig[kbvfeyi
Candidate:	keyifyibuezo;k^kj]jatch[j
Candidate:	keyi`wfd[jj^ni`qe\mf_o{\
Candidate:	keyc`t>^o8`sc]teaylibrk`n
Candidate:	keyik_oh\li]mpdvk]pfxkn^o
Candidate:	keyig[kg[ml^qi[n]ob^ud_xh
Candidate:	keyie\mdznhwmbtizlc[neuka
Candidate:	keykauecxfbrcftfbpberdbpb
Candidate:	keykeykeyke\mi`of_mf]nbxl
Candidate:	keykeyke\mi`of_mf]nbxl`vj
Candidate:	keyke\mi`of_mf]nbxl`vj_ri
Candidate:	keyiatdexhk^nczibwei\ih[h
Candidate:	keykwi>vh?jyqudzqcxhzqexp
Candidate:	keyibq?ncqn]m{lyzj;obrgzi
Candidate:	keyhbvmj;86'.,-+-+86)-
Candidate:	keyyovzqhmezjbwsl\mdsp
Candidate:	keyimh541 60?7"k@*
Candidate:	keymg~rj~rjnb:]q'au+pd:^r
Candidate:	keys.inject([]) { |acc, k
Candidate:	keywords : {
		exp  : /\b
Candidate:	keydown(function(event) {
Candidate:	key = event.keycode;
    
Candidate:	keycode;
    if (event.ct
Candidate:	key || event.altkey || ev
Candidate:	key || event.metakey) { r
Candidate:	key) { return; }

    if 
Candidate:	key == 89) // y for timer
Candidate:	tokens, _} = erl_scan:str
Candidate:	tokens),
  bindings = erl
Candidate:	tokens, _} = erl_scan:str
Candidate:	tokens),
  bindings = erl
Candidate:	key, ctx, mod) ->
  get(k
Candidate:	key, ?mustache_ctx:module
Candidate:	key, ctx) when is_list(ke
Candidate:	key) ->
  get(list_to_ato
Candidate:	key), ctx);
get(key, ctx)
Candidate:	key, ctx) ->
  case ?must
Candidate:	key, ctx) of
    {ok, val
Candidate:	key, '__mod__').
-define(
Candidate:	keydelete(?module_key, 1,
Candidate:	key, 1, list).

%% ======
Candidate:	key, ctx) of
        {ok,
Candidate:	key, module, ctx).

%% ==
Candidate:	key, ctx) ->
    case dic
Candidate:	key, ctx) of
        {ok,
Candidate:	key, ctx)
    end.

get_f
Candidate:	key, ctx) ->
    funlist 
Candidate:	key(ctx) end,
           
Candidate:	key() end
            ]
 
Candidate:	api */
  
  set fillstyle
Candidate:	api */
  
  rect: functio
Candidate:	token is recognized, or
%
Candidate:	tokens are one of the fol
Candidate:	token([]) -> {more, []};

Candidate:	token(eof) -> {done, eof,
Candidate:	token("true" ++ rest) -> 
Candidate:	token("tru")	-> {more, "t
Candidate:	token("tr")	-> {more, "tr
Candidate:	token("t")	-> {more, "t"}
Candidate:	token("false" ++ rest) ->
Candidate:	token("fals")	-> {more, "
Candidate:	token("fal")	-> {more, "f
Candidate:	token("fa")	-> {more, "fa
Candidate:	token("f")	-> {more, "f"}
Candidate:	token("null" ++ rest) -> 
Candidate:	token("nul")	-> {more, "n
Candidate:	token("nu")	-> {more, "nu
Candidate:	token("n")	-> {more, "n"}
Candidate:	token([c | cs] = input) -
Candidate:	token(cs);	% eat whitespa
Candidate:	token(cs);	% eat whitespa
Candidate:	token(cs);	% eat whitespa
Candidate:	token(cs);	% eat whitespa
Candidate:	token(chars)
	end;
      
Candidate:	token(oldchars ++ charlis
Candidate:	tokenoreof, chars)

get_t
Candidate:	token(chars, kt) ->
    c
Candidate:	token(chars) of
	{done, {
Candidate:	token(chars, fun(t, c2) -
Candidate:	token must be string
	end
Candidate:	token(c, fun
        (col
Candidate:	token(c, fun
        (eof
Candidate:	token(c3, fun
           
Candidate:	token(c4, fun(t3, c5) ->

Candidate:	token(c, fun
        (eof
Candidate:	token(c2, fun
           
Candidate:	token(c3, fun(t3, c4) ->

Candidate:	key/2]).
-export([obj_sto
Candidate:	keys
%%%	true, false, nul
Candidate:	keys may be atoms or stri
Candidate:	keys may be either string
Candidate:	keys.
%% note that order 
Candidate:	key, value}, acc) ->
	s =
Candidate:	key of
	    l when is_lis
Candidate:	key, key}})
	end,
	v = en
Candidate:	key}})
	end,
	v = encode(
Candidate:	key, {json_object, props}
Candidate:	key, props) of
        un
Candidate:	key, key});
        value
Candidate:	key});
        value ->
 
Candidate:	key, {json_object, props}
Candidate:	key, props) of
        un
Candidate:	key(key, {json_object, pr
Candidate:	key, {json_object, props}
Candidate:	key, props).

%% store a 
Candidate:	key, value, {json_object,
Candidate:	key, value} | proplists:d
Candidate:	key, props)]}.

%% create
Candidate:	key/value pairs.

obj_fro
Candidate:	keysort(1, props1),
    l
Candidate:	keysort(1, props2),
    p
Candidate:	tokens(method, ":"),
  
 
Candidate:	keysearch("method", 1, bo
Candidate:	keysearch("params", 1, bo
Candidate:	keysearch("id", 1, body),
Candidate:	api packages() called for
Candidate:	api declare_packages() ca
Candidate:	api

  def get_config(key
Candidate:	api bases
  #

  def srcd
Candidate:	api

  def initialize(con
Candidate:	api base methods
  #

  d
Candidate:	key)
    lookup(key).reso
Candidate:	key).resolve(self)
  end

Candidate:	key, val)
    lookup(key)
Candidate:	key).set val
  end

  def
Candidate:	key?(name)
    @table.key
Candidate:	key?(name)
  end

  def l
Candidate:	keys.join('|')})(?:=(.*))
Candidate:	key?(name)
    end

    d
Candidate:	key)
    @config[key]
  e
Candidate:	key]
  end

  alias confi
Candidate:	key, val)
    @config[key
Candidate:	key] = val
  end

  #
  #
Candidate:	key)
    @config[key]
  e
Candidate:	key]
  end

  def inspect
Candidate:	keys.select {|name|
     
Candidate:	key?(name)
    end
    a

Candidate:	key, an array of ints, ea
Candidate:	key) {
  var i, j, t;
  f
Candidate:	key[i % key.length]) & 25
Candidate:	key.length]) & 255;
    t
Candidate:	keypress='rng_seed_time()
Candidate:	key constructor
function 
Candidate:	key() {
  this.n = null;

Candidate:	key fields n and e from h
Candidate:	key");
}

// perform raw 
Candidate:	key.prototype.dopublic = 
Candidate:	key.prototype.setpublic =
Candidate:	key.prototype.encrypt = r
Candidate:	key.prototype.encrypt_b64
Candidate:	key fields n, e, and d fr
Candidate:	key");
}

// set the priv
Candidate:	key fields n, e, d and cr
Candidate:	key");
}

// generate a n
Candidate:	key b bits long, using pu
Candidate:	key.prototype.doprivate =
Candidate:	key.prototype.setprivate 
Candidate:	key.prototype.setprivatee
Candidate:	key.prototype.generate = 
Candidate:	key.prototype.decrypt = r
Candidate:	key.prototype.b64_decrypt
Candidate:	key();
var text = "the qu
Candidate:	keybord, a clock, or some
Candidate:	aping a whitespace char:

Candidate:	token(type, val, pos) {
 
Candidate:	token.eof = 0/*eof*/;
sc_
Candidate:	token.open_par = 1/*open_
Candidate:	token.close_par = 2/*clos
Candidate:	token.open_brace = 3/*ope
Candidate:	token.close_brace = 4/*cl
Candidate:	token.open_bracket = 5/*o
Candidate:	token.close_bracket = 6/*
Candidate:	token.whitespace = 7/*whi
Candidate:	token.quote = 8/*quote*/;
Candidate:	token.id = 9/*id*/;
sc_to
Candidate:	token.dot = 10/*dot*/;
sc
Candidate:	token.string = 11/*string
Candidate:	token.number = 12/*number
Candidate:	token.error = 13/*error*/
Candidate:	token.vector_begin = 14/*
Candidate:	token.true = 15/*true*/;

Candidate:	token.false = 16/*false*/
Candidate:	token.unspecified = 17/*u
Candidate:	token.reference = 18/*ref
Candidate:	token.store = 19/*store*/
Candidate:	token.char = 20/*char*/;

Candidate:	tokenizer(port) {
    thi
Candidate:	tokenizer.prototype.peekt
Candidate:	token = function() {
    
Candidate:	token = this.nexttoken();
Candidate:	token();
    this.peeked 
Candidate:	token;
    return newtoke
Candidate:	token;
};
sc_tokenizer.pr
Candidate:	tokenizer.prototype.readt
Candidate:	token = function() {
    
Candidate:	token();
    delete this.
Candidate:	tokenizer.prototype.nextt
Candidate:	token = function() {
    
Candidate:	token(11/*string*/, res);
Candidate:	token(13/*error*/, "unclo
Candidate:	token(13/*error*/, "unclo
Candidate:	token(9/*id*/, res);
	els
Candidate:	token(12/*number*/, res -
Candidate:	token(10/*dot*/);
	else
	
Candidate:	token(13/*error*/, "bad #
Candidate:	token(18/*reference*/, nb
Candidate:	token(19/*store*/, nb);
	
Candidate:	token(13/*error*/, "bad #
Candidate:	token(14/*vector_begin*/)
Candidate:	token(13/*error*/, "bad #
Candidate:	token(20/*char*/, port.re
Candidate:	token(20/*char*/, tmp);
	
Candidate:	token(20/*char*/, entry);
Candidate:	token(13/*error*/, "unkno
Candidate:	token(15/*true*/, true); 
Candidate:	token(16/*false*/, false)
Candidate:	token(17/*unspecified*/, 
Candidate:	token(13/*error*/, "bad #
Candidate:	token(13/*error*/, "bad #
Candidate:	token(13/*error*/, "bad #
Candidate:	token(0/*eof*/, curchar);
Candidate:	token(1/*open_par*/);
   
Candidate:	token(2/*close_par*/);
  
Candidate:	token(3/*open_brace*/);
 
Candidate:	token(4/*close_brace*/);

Candidate:	token(5/*open_bracket*/);
Candidate:	token(6/*close_bracket*/)
Candidate:	token(8/*quote*/);
    ca
Candidate:	tokenizer) {
    this.tok
Candidate:	tokenizer = tokenizer;
  
Candidate:	tokenizer;
    this.backr
Candidate:	token = tokenizer.peektok
Candidate:	tokenizer.peektoken();
	 
Candidate:	token();
	    
	    switc
Candidate:	token.type) {
	    case 2
Candidate:	token.type)) {
		    toke
Candidate:	tokenizer.readtoken(); //
Candidate:	token(); // consume token
Candidate:	token
		    return sc_rev
Candidate:	tokenizer.readtoken(); //
Candidate:	token(); // consume token
Candidate:	token
		var cdr = this.re
Candidate:	tokenizer.readtoken();
		
Candidate:	token();
		if (!matchespe
Candidate:	token = tokenizer.peektok
Candidate:	tokenizer.peektoken();
	 
Candidate:	token();
	    switch (tok
Candidate:	token.type) {
	    case 2
Candidate:	tokenizer.readtoken();
		
Candidate:	token();
		return a;
		
	
Candidate:	tokenizer = this.tokenize
Candidate:	tokenizer;

    var token
Candidate:	token = tokenizer.readtok
Candidate:	tokenizer.readtoken();

 
Candidate:	token();

    // handle e
Candidate:	token.type === 13/*error*
Candidate:	token.val;
    
    switc
Candidate:	token.type) {
    case 1/
Candidate:	token.type);
    case 8/*
Candidate:	token.val);
    case 20/*
Candidate:	token.val);
    case 14/*
Candidate:	token.val);
    case 19/*
Candidate:	token.val);
    case 9/*i
Candidate:	token.val);
    case 0/*e
Candidate:	token.val;
    default:
	
Candidate:	token " + token.type + " 
Candidate:	token.type + " " + token.
Candidate:	token.val;
    }
};

/***
Candidate:	tokenizer(port));
    ret
Candidate:	key, val) {
    var ht = 
Candidate:	key] = val;
}

/*** meta 
Candidate:	key) {
    var ht = sc_pr
Candidate:	key in ht)
	    return ht
Candidate:	key];
	else
	    return f
Candidate:	key) {
    var ht = sc_pr
Candidate:	key];
}

/*** meta ((expo
Candidate:	key, val) {
    this.key 
Candidate:	key = key;
    this.val =
Candidate:	key;
    this.val = val;

Candidate:	key, val) {
    var hash 
Candidate:	key);
    ht[hash] = new 
Candidate:	key, val);
}

/*** meta (
Candidate:	key) {
    var hash = sc_
Candidate:	key);
    if (hash in ht)
Candidate:	key, ht[v].val);
    }
}

Candidate:	key) {
    var hash = sc_
Candidate:	key);
    if (hash in ht)
Candidate:	keyword_prefix = "\u1e9d"
Candidate:	keyword2jsstring(k) {
   
Candidate:	keyword(s) {
    return s
Candidate:	keyword_prefix + s;
}

/*
Candidate:	keyword(s) {
    return (
Candidate:	keyword_prefix);
}


/***
Candidate:	keyword2string(o) {
    r
Candidate:	keyword(o) {
    return s
Candidate:	keyword_prefix + o;
}

st
Candidate:	keyword_prefix)
	return "
Candidate:	keyword_prefix)
	return "
Candidate:	apitalize: function(){
  
Candidate:	apitalize()] + 'px';

   
Candidate:	keys: function(object) {

Candidate:	keys = [];
    for (var p
Candidate:	keys.push(property);
    
Candidate:	keys;
  },

  values: fun
Candidate:	key) return;

      if (p
Candidate:	key = encodeuricomponent(
Candidate:	key);
          values.ea
Candidate:	key + '=' + encodeuricomp
Candidate:	key in this) {
      var 
Candidate:	key];
      if (value && 
Candidate:	key]) continue;

      va
Candidate:	key, value];
      pair.k
Candidate:	key = key;
      pair.val
Candidate:	key;
      pair.value = v
Candidate:	keys: function() {
    re
Candidate:	key');
  },

  values: fu
Candidate:	key] = pair.value;
      
Candidate:	key] = pair.value });
   
Candidate:	key: "accesskey",
  tabin
Candidate:	key",
  tabindex:  "tabin
Candidate:	key = element.name, value
Candidate:	key]) {
            if (r
Candidate:	key].constructor != array
Candidate:	key] = [result[key]];
   
Candidate:	key]];
            result
Candidate:	key].push(value);
       
Candidate:	key] = value;
        }
 
Candidate:	key_backspace: 8,
  key_t
Candidate:	key_tab:       9,
  key_r
Candidate:	key_return:   13,
  key_e
Candidate:	key_esc:      27,
  key_l
Candidate:	key_left:     37,
  key_u
Candidate:	key_up:       38,
  key_r
Candidate:	key_right:    39,
  key_d
Candidate:	key_down:     40,
  key_d
Candidate:	key_delete:   46,
  key_h
Candidate:	key_home:     36,
  key_e
Candidate:	key_end:      35,
  key_p
Candidate:	key_pageup:   33,
  key_p
Candidate:	key_pagedown: 34,

  elem
Candidate:	keypress' &&
        (nav
Candidate:	keydown';

    event._obs
Candidate:	keypress' &&
        (nav
Candidate:	keydown';

    if (elemen
Candidate:	api reference guide
 *	
 
Candidate:	apis/v8/
 */

#ifndef _v8
Candidate:	api object templates.
 */
Candidate:	token for the context.  t
Candidate:	tokens must match.
   */

Candidate:	token(handle<value> token
Candidate:	token);

  /** returns th
Candidate:	token of this context.*/

Candidate:	token();

  /**
   * ente
Candidate:	key,
           handle<va
Candidate:	key);

  // todo(1245389)
Candidate:	key.
  bool has(handle<st
Candidate:	key);
  bool delete(handl
Candidate:	key);
  bool has(uint32_t
Candidate:	key);
  bool hasrealindex
Candidate:	key);

  /**
   * if resu
Candidate:	key);

  /** tests for a 
Candidate:	keys
};


/**
 * returns 
Candidate:	key on the global object.
Candidate:	key,
                    
Candidate:	key = objecttostring(name
Candidate:	key);

  // if the key is
Candidate:	key is not present return
Candidate:	key and value to std::str
Candidate:	key = objecttostring(name
Candidate:	key] = value;

  // retur
Candidate:	key = arg.substr(0, index
Candidate:	key] = value;
    }
  }
}
Candidate:	key behaves this way.
  i
Candidate:	api.h"
#include "bootstra
Candidate:	api(expr) log(apientrycal
Candidate:	apientrycall(expr))


nam
Candidate:	api_fatal(location, messa
Candidate:	apifailure(const char* lo
Candidate:	apicheck(bool condition,

Candidate:	apifailure(location, mess
Candidate:	apicheck(v8::v8::initiali
Candidate:	api<primitive>(i::factory
Candidate:	api<primitive>(i::factory
Candidate:	api<boolean>(i::factory::
Candidate:	api<boolean>(i::factory::
Candidate:	api("undefined");
  retur
Candidate:	api("null");
  return imp
Candidate:	api("true");
  return imp
Candidate:	api("false");
  return im
Candidate:	api("persistent::new");
 
Candidate:	api("makeweak");
  i::glo
Candidate:	api("clearweak");
  i::gl
Candidate:	api("isglobalneardeath");
Candidate:	api("isglobalweak");
  if
Candidate:	api("disposeglobal");
  i
Candidate:	apicheck(current_.extensi
Candidate:	apicheck(thread_local.lea
Candidate:	apicheck(!is_closed_,
   
Candidate:	api("closehandlescope");

Candidate:	api<objecttemplate>(resul
Candidate:	api("functiontemplate::ne
Candidate:	api("signature::new");
  
Candidate:	api("typeswitch::new");
 
Candidate:	api("typeswitch::match");
Candidate:	api("objecttemplate::new"
Candidate:	apicheck(i::smi::isvalid(
Candidate:	api("script::compile");
 
Candidate:	api<script>(result));
}


Candidate:	api("script::run");
  i::
Candidate:	api("tostring");
  i::han
Candidate:	api<string>(str));
}


lo
Candidate:	api("todetailstring");
  
Candidate:	api<string>(str));
}


lo
Candidate:	api("toobject");
  i::han
Candidate:	api<object>(val));
}


lo
Candidate:	api("toboolean");
  i::ha
Candidate:	api<boolean>(val));
}


l
Candidate:	api("tonumber");
  i::han
Candidate:	api<number>(num));
}


lo
Candidate:	api("tointeger");
  i::ha
Candidate:	api<integer>(num));
}


e
Candidate:	apicheck(obj->isproxy(),

Candidate:	apicheck(obj->isjsobject(
Candidate:	apicheck(obj->isjsfunctio
Candidate:	apicheck(obj->isstring(),
Candidate:	apicheck(obj->isnumber(),
Candidate:	apicheck(obj->isnumber(),
Candidate:	apicheck(obj->isjsarray()
Candidate:	api("booleanvalue");
  i:
Candidate:	api("numbervalue");
  i::
Candidate:	api("integervalue");
  i:
Candidate:	api("toint32");
  i::hand
Candidate:	api<int32>(num));
}


loc
Candidate:	api("touint32");
  i::han
Candidate:	api<uint32>(num));
}


lo
Candidate:	api("toarrayindex");
  i:
Candidate:	api("int32value");
  i::h
Candidate:	api("int32value (slow)");
Candidate:	api("equals");
  i::handl
Candidate:	api("strictequals");
  i:
Candidate:	api("uint32value");
  i::
Candidate:	api("function::newinstanc
Candidate:	api("function::call");
  
Candidate:	api("string::writeascii")
Candidate:	api("string::write");
  a
Candidate:	apicheck(index < obj->get
Candidate:	apicheck(index < obj->get
Candidate:	api("context::new");
  on
Candidate:	apicheck(!env.is_null(),

Candidate:	api("objecttemplate::newi
Candidate:	api("functiontemplate::ge
Candidate:	api("external::new");
  e
Candidate:	api("string::new(char)");
Candidate:	api("string::newundetecta
Candidate:	api("string::new(uint16_)
Candidate:	api("string::newundetecta
Candidate:	api("string::newexternal"
Candidate:	api("string::newexternal"
Candidate:	api("object::new");
  i::
Candidate:	api("date::new");
  excep
Candidate:	api("array::new");
  i::h
Candidate:	api("string::newsymbol(ch
Candidate:	api("rangeerror");
  on_b
Candidate:	api("referenceerror");
  
Candidate:	api("syntaxerror");
  on_
Candidate:	api("typeerror");
  on_ba
Candidate:	api("error");
  on_bailou
Candidate:	token(handle<value> token
Candidate:	token) {
  i::handle<i::c
Candidate:	token_handle = utils::ope
Candidate:	token);
  // the global o
Candidate:	token and reference to th
Candidate:	token(*token_handle);
}


Candidate:	token_handle);
}


handle
Candidate:	token() {
  i::handle<i::
Candidate:	token =
      i::jsglobal
Candidate:	token();
  i::handle<i::o
Candidate:	token_handle(security_tok
Candidate:	token);
  return utils::t
Candidate:	token_handle);
}


bool c
Candidate:	key, v8::handle<value> va
Candidate:	key_obj = utils::openhand
Candidate:	key);
  i::handle<i::obje
Candidate:	key_obj,
      value_obj,
Candidate:	key) {
  on_bailout("v8::
Candidate:	key_obj = utils::openhand
Candidate:	key);
  exception_preambl
Candidate:	key_obj);
  has_pending_e
Candidate:	key) {
  on_bailout("v8::
Candidate:	key_obj = utils::openhand
Candidate:	key);
  return i::deletep
Candidate:	key_obj)->istrue();
}


b
Candidate:	key) {
  on_bailout("v8::
Candidate:	key_obj = utils::openhand
Candidate:	key);
  return self->hasp
Candidate:	key_obj);
}


bool v8::ob
Candidate:	key) {
  on_bailout("v8::
Candidate:	key));
}


bool v8::objec
Candidate:	key) {
  on_bailout("v8::
Candidate:	key));
}


bool v8::objec
Candidate:	key) {
  on_bailout("v8::
Candidate:	key_obj = utils::openhand
Candidate:	key);
  i::lookupresult l
Candidate:	key_obj, &lookup);
  if (
Candidate:	key_obj,
                
Candidate:	api_h_
#define v8_api_h_

Candidate:	api_h_

#include "factory
Candidate:	api.  the most natural th
Candidate:	api.
class neanderobject 
Candidate:	apifailure(const char* lo
Candidate:	api(v8::internal::handle<
Candidate:	api_h_

Candidate:	api.  see
// v8natives.js
Candidate:	apifunctioncache = {};
co
Candidate:	apifunctioncache;


funct
Candidate:	apitagoffset);
  switch (
Candidate:	apiconstructoroffset);
  
Candidate:	api tag <' + tag + '>';
 
Candidate:	apiserialnumberoffset);
 
Candidate:	apifunctioncache)) {
    
Candidate:	apifunctioncache[serialnu
Candidate:	apifunction(data);
    ka
Candidate:	apifunctioncache[serialnu
Candidate:	apiprototypetemplateoffse
Candidate:	apiparenttemplateoffset);
Candidate:	apifunctioncache[serialnu
Candidate:	apipropertylistoffset);
 
Candidate:	keys.  useful for operati
Candidate:	keys(array, intervals) {

Candidate:	keys = [];
  for (var k =
Candidate:	key = intervals[k];
    i
Candidate:	key < 0) {
      var j = 
Candidate:	key;
      var limit = j 
Candidate:	keys.push(j);
        }
 
Candidate:	key is undefined also end
Candidate:	key)) {
        var e = a
Candidate:	key];
        if (!is_und
Candidate:	key in array) {
         
Candidate:	keys.push(key);
        }
Candidate:	key);
        }
      }
 
Candidate:	keys.sort(function(a, b) 
Candidate:	keys;
}


// optimized fo
Candidate:	keys = getsortedarraykeys
Candidate:	keys(array, %getarraykeys
Candidate:	keys(array, len));
  var 
Candidate:	key = -1;
  var keys_leng
Candidate:	keys_length = keys.length
Candidate:	keys.length;
  for (var i
Candidate:	keys_length; i++) {
    v
Candidate:	key = keys[i];
    if (ke
Candidate:	keys[i];
    if (key != l
Candidate:	key != last_key) {
      
Candidate:	key) {
      var e = arra
Candidate:	key];
      builder.add(c
Candidate:	key = key;
    }
  }
  re
Candidate:	key;
    }
  }
  return b
Candidate:	keys and intervals.  see 
Candidate:	keys(array, start_i + del
Candidate:	key = intervals[k];
    i
Candidate:	key < 0) {
      var j = 
Candidate:	key;
      var interval_l
Candidate:	key)) {
        if (key >
Candidate:	key >= start_i) {
       
Candidate:	key];
          if (!is_u
Candidate:	key in array) {
         
Candidate:	key - start_i] = current;
Candidate:	keys(array, len);
  var l
Candidate:	key = intervals[k];
    i
Candidate:	key < 0) {
      var j = 
Candidate:	key;
      var interval_l
Candidate:	key)) {
        if (key <
Candidate:	key < start_i) {
        
Candidate:	key];
          if (!is_u
Candidate:	key in array)
           
Candidate:	key] = current;
        }
Candidate:	key >= start_i + del_coun
Candidate:	key];
          if (!is_u
Candidate:	key in array)
           
Candidate:	key - del_count + num_add
Candidate:	keys.  keys are
      // 
Candidate:	keys are
      // represe
Candidate:	keys(e, e.length);
      
Candidate:	key = intervals[k];
     
Candidate:	key < 0) {
          var 
Candidate:	key;
          var limit 
Candidate:	key is undefined also end
Candidate:	key)) {
            a[n +
Candidate:	key] = e[key];
          
Candidate:	key];
          }
       
Candidate:	keys = getsortedarraykeys
Candidate:	keys(array, %getarraykeys
Candidate:	keys(array, len));
  var 
Candidate:	keys.length - 1;
  var lo
Candidate:	keys[low_counter];
    va
Candidate:	keys[high_counter];

    
Candidate:	keys[--high_counter] == j
Candidate:	keys[++low_counter] == i)
Candidate:	key and kjs return undefi
Candidate:	key and kjs treat the cas
Candidate:	key in properties) {
    
Candidate:	key, properties[key], att
Candidate:	key], attributes);
  }
};
Candidate:	key in lengths) {
    %fu
Candidate:	key], lengths[key]);
  }

Candidate:	key]);
  }
};


// ------
Candidate:	keywords are resolved via
Candidate:	token::value assignment::
Candidate:	token::assign_bit_or: ret
Candidate:	token::bit_or;
    case t
Candidate:	token::assign_bit_xor: re
Candidate:	token::bit_xor;
    case 
Candidate:	token::assign_bit_and: re
Candidate:	token::bit_and;
    case 
Candidate:	token::assign_shl: return
Candidate:	token::shl;
    case toke
Candidate:	token::assign_sar: return
Candidate:	token::sar;
    case toke
Candidate:	token::assign_shr: return
Candidate:	token::shr;
    case toke
Candidate:	token::assign_add: return
Candidate:	token::add;
    case toke
Candidate:	token::assign_sub: return
Candidate:	token::sub;
    case toke
Candidate:	token::assign_mul: return
Candidate:	token::mul;
    case toke
Candidate:	token::assign_div: return
Candidate:	token::div;
    case toke
Candidate:	token::assign_mod: return
Candidate:	token::mod;
    default: 
Candidate:	token::illegal;
}


bool 
Candidate:	key, expression* value) {
Candidate:	key_ = key;
  value_ = va
Candidate:	key;
  value_ = value;
  
Candidate:	key->handle();
  if (k->i
Candidate:	key_ = new literal(value-
Candidate:	aping_labels_(null) { }


Candidate:	aping_labels(zonelist<lab
Candidate:	aping_labels_ = labels;
 
Candidate:	aping_labels() const { re
Candidate:	aping_labels_; }

 privat
Candidate:	aping_labels_;
};


class
Candidate:	token.h"
#include "variab
Candidate:	token::value op, expressi
Candidate:	token::isunaryop(op));
  
Candidate:	token::value op() const {
Candidate:	token::value op_;
  expre
Candidate:	token::value op, expressi
Candidate:	token::isbinaryop(op));
 
Candidate:	token::comma:
      case 
Candidate:	token::or:
      case tok
Candidate:	token::and:
        retur
Candidate:	token::bit_or:
      case
Candidate:	token::bit_xor:
      cas
Candidate:	token::bit_and:
      cas
Candidate:	token::shl:
      case to
Candidate:	token::sar:
      case to
Candidate:	token::shr:
      case to
Candidate:	token::add:
      case to
Candidate:	token::sub:
      case to
Candidate:	token::mul:
      case to
Candidate:	token::div:
      case to
Candidate:	token::mod:
        retur
Candidate:	token::value op() const {
Candidate:	token::value op_;
  expre
Candidate:	token::value op, expressi
Candidate:	token::iscountop(op));
  
Candidate:	token::value op() const {
Candidate:	token::value op_;
  expre
Candidate:	token::value op, expressi
Candidate:	token::iscompareop(op));

Candidate:	token::value op() const {
Candidate:	token::value op_;
  expre
Candidate:	token::value op, expressi
Candidate:	token::isassignmentop(op)
Candidate:	token::value binary_op() 
Candidate:	token::value op() const {
Candidate:	token::value op_;
  expre
Candidate:	token_position_(knopositi
Candidate:	token_position(int pos) {
Candidate:	token_position_ = pos; }

Candidate:	token_position() const { 
Candidate:	token_position_; }
  int 
Candidate:	token_position_;
};


cla
Candidate:	key, expression* value);

Candidate:	key() { return key_; }
  
Candidate:	key_; }
    expression* v
Candidate:	key_;
    expression* val
Candidate:	key, int pos)
      : obj
Candidate:	key_(key), pos_(pos) { }

Candidate:	key), pos_(pos) { }

  vi
Candidate:	key() const { return key_
Candidate:	key_; }
  int position() 
Candidate:	key_;
  int pos_;

  // d
Candidate:	api.h"
#include "bootstra
Candidate:	apifunction(global_constr
Candidate:	apicallasfunction));
  ha
Candidate:	apifailure(
        "v8::
Candidate:	apifailure(
        "v8::
Candidate:	apifailure(
        "v8::
Candidate:	token of the global objec
Candidate:	token(*global_context());
Candidate:	token for the debugger gl
Candidate:	token(global->security_to
Candidate:	token());
  }

  return t
Candidate:	key = handle<string>(stre
Candidate:	key());
          int ind
Candidate:	key, value, details.attri
Candidate:	key = handle<string>(stre
Candidate:	key());
          handle<
Candidate:	key, fun, details.attribu
Candidate:	key(), &result);
        
Candidate:	key = handle<string>(stre
Candidate:	key());
          handle<
Candidate:	key,
                    
Candidate:	key(properties->keyat(i))
Candidate:	keyat(i));
      if (prop
Candidate:	key(raw_key)) {
        a
Candidate:	key)) {
        assert(ra
Candidate:	key->isstring());
       
Candidate:	key), &result);
        i
Candidate:	key = handle<string>(stri
Candidate:	key));
        handle<obj
Candidate:	key, value, details.attri
Candidate:	key = factory::lookupasci
Candidate:	key));
  if (value->isjsf
Candidate:	key,
                    
Candidate:	keyedloadic_debugbreak(ma
Candidate:	keyed load ic not impleme
Candidate:	keyedstoreic_debugbreak(m
Candidate:	keyed store ic not implem
Candidate:	keyedloadic_initialize));
Candidate:	keyedloadic_debugbreak(ma
Candidate:	keyed ic load call (from 
Candidate:	keyedstoreic_debugbreak(m
Candidate:	keyed ic load call (from 
Candidate:	keyed ic call call (from 
Candidate:	api.h"
#include "bootstra
Candidate:	apicall) {
  handlescope 
Candidate:	api calls in a more direc
Candidate:	apiobjectaccess("call", j
Candidate:	api that
// support calls
Candidate:	apicallasfunction) {
  //
Candidate:	apiobjectaccess("call non
Candidate:	keyedloadic_initialize(ma
Candidate:	keyedloadic::generateinit
	KEY FOUND:	keyedloadic::generateinit
Candidate:	keyedloadic_miss(macroass
Candidate:	keyedloadic::generatemiss
	KEY FOUND:	keyedloadic::generatemiss
Candidate:	keyedloadic_generic(macro
Candidate:	keyedloadic::generategene
	KEY FOUND:	keyedloadic::generategene
Candidate:	keyedloadic_premonomorphi
Candidate:	keyedloadic::generateprem
	KEY FOUND:	keyedloadic::generateprem
Candidate:	keyedstoreic_generic(macr
Candidate:	keyedstoreic::generategen
	KEY FOUND:	keyedstoreic::generategen
Candidate:	keyedstoreic_miss(macroas
Candidate:	keyedstoreic::generatemis
	KEY FOUND:	keyedstoreic::generatemis
Candidate:	keyedstoreic_initialize(m
Candidate:	keyedstoreic::generateini
	KEY FOUND:	keyedstoreic::generateini
Candidate:	apicall, 0)              
Candidate:	apicallasfunction, 0)


/
Candidate:	keyedloadic_miss,        
Candidate:	keyedstoreic_miss,       
Candidate:	keyedloadic_initialize,  
Candidate:	keyed_load_ic, uninitiali
Candidate:	keyedloadic_premonomorphi
Candidate:	keyed_load_ic, premonomor
Candidate:	keyedloadic_generic,     
Candidate:	keyed_load_ic, megamorphi
Candidate:	keyedloadic_debugbreak,  
Candidate:	keyed_load_ic, debug_brea
Candidate:	keyedstoreic_initialize, 
Candidate:	keyed_store_ic, uninitial
Candidate:	keyedstoreic_generic,    
Candidate:	keyed_store_ic, megamorph
Candidate:	keyedstoreic_debugbreak, 
Candidate:	keyed_store_ic, debug_bre
Candidate:	keyedloadic_initialize; m
Candidate:	keys, 0)               \

Candidate:	key, 1)             \
  v
Candidate:	keyedloadic_debugbreak(ma
Candidate:	keyedstoreic_debugbreak(m
Candidate:	api_fatal(const char* loc
Candidate:	api_fatal(const char* loc
Candidate:	tokens.  if one of the to
Candidate:	tokens is a macro the
// 
Candidate:	key = getkey();
  int ind
Candidate:	key();
  int index = heap
Candidate:	key);
  if (index == -1) 
Candidate:	key.
    code::flags flag
Candidate:	key(majorkey());

    // 
Candidate:	key());

    // add unres
Candidate:	key,
                    
Candidate:	key);
  }
  assert(index 
Candidate:	key) {
  switch (major_ke
Candidate:	key) {
    case callfunct
Candidate:	keyfromkey(uint32_t key) 
Candidate:	key(uint32_t key) {
    r
Candidate:	key) {
    return static_
Candidate:	keybits::decode(key));
  
Candidate:	key));
  };
  static int 
Candidate:	keyfromkey(uint32_t key) 
Candidate:	key(uint32_t key) {
    r
Candidate:	key) {
    return minorke
Candidate:	keybits::decode(key);
  }
Candidate:	key);
  };
  static const
Candidate:	key);

  virtual ~codestu
Candidate:	key.
  virtual major majo
Candidate:	key() = 0;
  virtual int 
Candidate:	key() = 0;

  // returns 
Candidate:	key based on major and mi
Candidate:	key() {
    assert(static
Candidate:	key()) < number_of_ids);

Candidate:	keybits::encode(minorkey(
Candidate:	key()) |
           major
Candidate:	keybits::encode(majorkey(
Candidate:	key());
  }

  bool allow
Candidate:	key() <= recordwrite; }


Candidate:	keybits: public bitfield<
Candidate:	keybits: public bitfield<
Candidate:	aping
  // labels and the
Candidate:	aping_labels()->length();
Candidate:	aping_labels()->at(i)));

Candidate:	aping
  // labels and the
Candidate:	aping_labels()->length();
Candidate:	aping_labels()->at(i)));

Candidate:	token::value op);
  void 
Candidate:	token::value op, handle<o
Candidate:	token::value op) : op_(op
Candidate:	token::value op_;

  majo
Candidate:	token::add: return "gener
Candidate:	token::sub: return "gener
Candidate:	token::mul: return "gener
Candidate:	token::div: return "gener
Candidate:	token::bit_or: return "ge
Candidate:	token::bit_and: return "g
Candidate:	token::bit_xor: return "g
Candidate:	token::sar: return "gener
Candidate:	token::shl: return "gener
Candidate:	token::shr: return "gener
Candidate:	token::string(op_)); }
#e
Candidate:	token::add: {
      label
Candidate:	token::sub: {
      label
Candidate:	token::mul: {
      label
Candidate:	token::bit_or:
    case t
Candidate:	token::bit_and:
    case 
Candidate:	token::bit_xor: {
      l
Candidate:	token::bit_or:  __ orr(r0
Candidate:	token::bit_and: __ and_(r
Candidate:	token::bit_xor: __ eor(r0
Candidate:	token::bit_or:  __ invoke
Candidate:	token::bit_and: __ invoke
Candidate:	token::bit_xor: __ invoke
Candidate:	token::shl:
    case toke
Candidate:	token::shr:
    case toke
Candidate:	token::sar: {
      label
Candidate:	token::sar:
          __ 
Candidate:	token::shr:
          __ 
Candidate:	token::shl:
          __ 
Candidate:	token::sar: __ invokebuil
Candidate:	token::shr: __ invokebuil
Candidate:	token::shl: __ invokebuil
Candidate:	token::value op) {
  // s
Candidate:	token::add:  // fall thro
Candidate:	token::sub:  // fall thro
Candidate:	token::mul:
    case toke
Candidate:	token::bit_or:
    case t
Candidate:	token::bit_and:
    case 
Candidate:	token::bit_xor:
    case 
Candidate:	token::shl:
    case toke
Candidate:	token::shr:
    case toke
Candidate:	token::sar: {
      __ po
Candidate:	token::div: {
      __ mo
Candidate:	token::mod: {
      __ mo
Candidate:	token::comma:
      __ po
Candidate:	token::value op,
        
Candidate:	token::add: {
        if 
Candidate:	token::sub: {
        if 
Candidate:	token::bit_or:
      case
Candidate:	token::bit_xor:
      cas
Candidate:	token::bit_and: {
       
Candidate:	token::shl:
      case to
Candidate:	token::shr:
      case to
Candidate:	token::sar: {
        if 
Candidate:	token::value op_;
  int v
Candidate:	token::value op,
        
Candidate:	token::add: {
      defer
Candidate:	token::sub: {
      defer
Candidate:	token::bit_or:
    case t
Candidate:	token::bit_xor:
    case 
Candidate:	token::bit_and: {
      d
Candidate:	token::bit_or:  __ orr(r0
Candidate:	token::bit_xor: __ eor(r0
Candidate:	token::bit_and: __ and_(r
Candidate:	token::shl:
    case toke
Candidate:	token::shr:
    case toke
Candidate:	token::sar: {
      if (r
Candidate:	token::shl: {
           
Candidate:	token::shr: {
           
Candidate:	token::sar: {
           
Candidate:	token::assign ||
      no
Candidate:	token::init_var ||
      
Candidate:	token::init_const) {
    
Candidate:	token::init_var && node->
Candidate:	token::init_const) {
    
Candidate:	token::init_const) {
    
Candidate:	token::value op = node->o
Candidate:	token::not) {
    loadcon
Candidate:	token::delete) {
    prop
Candidate:	token::typeof) {
    // s
Candidate:	token::not:
      case to
Candidate:	token::delete:
      case
Candidate:	token::typeof:
        un
Candidate:	token::sub: {
        una
Candidate:	token::bit_not: {
       
Candidate:	token::void:
        // s
Candidate:	token::add: {
        // 
Candidate:	token::inc;

  variable* 
Candidate:	token::value op = node->o
Candidate:	token::and) {
    label i
Candidate:	token::or) {
    label is
Candidate:	token::value op = node->o
Candidate:	token::eq || op == token:
Candidate:	token::eq_strict) {
    /
Candidate:	token::eq_strict) {
     
Candidate:	token::eq || op == token:
Candidate:	token::eq_strict) &&
    
Candidate:	token::typeof) &&
      (
Candidate:	token::eq:
      comparis
Candidate:	token::lt:
      comparis
Candidate:	token::gt:
      comparis
Candidate:	token::lte:
      compari
Candidate:	token::gte:
      compari
Candidate:	token::eq_strict:
      c
Candidate:	token::in:
      __ mov(r
Candidate:	token::instanceof:
      
Candidate:	keyed = 2 };
  reference(
Candidate:	key,
                    
Candidate:	key(variable->name());
  
Candidate:	key, knoposition);
    lo
Candidate:	key is a literal symbol.

Candidate:	key is a string that can 
Candidate:	key()->asliteral();
    u
Candidate:	key());
      ref->set_ty
Candidate:	keyed);
    }
  } else if
Candidate:	key() { return getpropert
Candidate:	key() { return 0; }
  voi
Candidate:	key
  // sp[1]: receiver

Candidate:	key and receiver object f
Candidate:	key is a smi.
  __ tst(r0
Candidate:	key (index) is within bou
Candidate:	key() { return setpropert
Candidate:	key() { return 0; }
  voi
Candidate:	key
  // sp[1] : receiver
Candidate:	key and the object from t
Candidate:	key, r3 = receiver
  // c
Candidate:	key is a smi.
  __ tst(r1
Candidate:	key against length in the
Candidate:	key (for checking against
Candidate:	key, r3 == object
  __ st
Candidate:	key, r2 == elements, r3 =
Candidate:	key has been incremented 
Candidate:	key against the length in
Candidate:	key, r2 == elements, r3 =
Candidate:	key() { return genericbin
Candidate:	key() { return static_cas
Candidate:	key() { return invokebuil
Candidate:	key() { return (argc_ << 
Candidate:	key() { return jsexit; }

Candidate:	key() { return static_cas
Candidate:	key() { return argumentsa
Candidate:	key() { return is_length_
Candidate:	key is a smi.
    label s
Candidate:	key,
    codegenstate::ac
Candidate:	key->asliteral();
    han
Candidate:	keyed property.
    asser
Candidate:	keyed);

    if (is_load)
Candidate:	keyed loads as on ia32.
 
Candidate:	key() { return callfuncti
Candidate:	key() { return argc_; }
}
Candidate:	key, end_del_check, fixed
Candidate:	key and kjs ignore null a
Candidate:	key.
  __ ldr(r1, memoper
Candidate:	key", 1, call_js);
  __ m
Candidate:	key = property->key();
  
Candidate:	key();
    expression* va
Candidate:	key);
        load(value)
Candidate:	key);
        __ mov(r0, 
Candidate:	key);
        __ mov(r0, 
Candidate:	key(), access());

  } el
Candidate:	key is a literal string.

Candidate:	key()->asliteral();

    
Candidate:	key"](1, 2, 3)'
      // 
Candidate:	key onto the stack and se
Candidate:	key].
  argumentsaccessst
Candidate:	key());
      __ mov(r0, 
Candidate:	aping
  // labels and the
Candidate:	aping_labels()->length();
Candidate:	aping_labels()->at(i)));

Candidate:	aping
  // labels and the
Candidate:	aping_labels()->length();
Candidate:	aping_labels()->at(i)));

Candidate:	token::value op,
      co
Candidate:	token::value op,
        
Candidate:	token::value op, overwrit
Candidate:	token::value op_;
  overw
Candidate:	token::string(op_),
     
Candidate:	token::value, 2, 14> {};

Candidate:	token::add: return "gener
Candidate:	token::sub: return "gener
Candidate:	token::mul: return "gener
Candidate:	token::div: return "gener
Candidate:	token::bit_or: return "ge
Candidate:	token::bit_and: return "g
Candidate:	token::bit_xor: return "g
Candidate:	token::sar: return "gener
Candidate:	token::shl: return "gener
Candidate:	token::shr: return "gener
Candidate:	token::add: {
      // ea
Candidate:	token::sub: {
      // ea
Candidate:	token::mul: {
      // ea
Candidate:	token::div: {
      // ea
Candidate:	token::mod: {
      label
Candidate:	token::bit_or:
    case t
Candidate:	token::bit_and:
    case 
Candidate:	token::bit_xor:
    case 
Candidate:	token::sar:
    case toke
Candidate:	token::shl:
    case toke
Candidate:	token::shr: {
      // sm
Candidate:	token::add:
    case toke
Candidate:	token::sub:
    case toke
Candidate:	token::mul:
    case toke
Candidate:	token::div: {
      // ea
Candidate:	token::add: __ faddp(1); 
Candidate:	token::sub: __ fsubp(1); 
Candidate:	token::mul: __ fmulp(1); 
Candidate:	token::div: __ fdivp(1); 
Candidate:	token::mod: {
      // fo
Candidate:	token::bit_or:
    case t
Candidate:	token::bit_and:
    case 
Candidate:	token::bit_xor:
    case 
Candidate:	token::sar:
    case toke
Candidate:	token::shl:
    case toke
Candidate:	token::shr: {
      float
Candidate:	token::bit_or:  __ or_(ea
Candidate:	token::bit_and: __ and_(e
Candidate:	token::bit_xor: __ xor_(e
Candidate:	token::sar: __ sar(eax); 
Candidate:	token::shl: __ shl(eax); 
Candidate:	token::shr: __ shr(eax); 
Candidate:	token::shr) {
        __ 
Candidate:	token::shr) __ bind(&non_
Candidate:	token::add:
      __ invo
Candidate:	token::sub:
      __ invo
Candidate:	token::mul:
      __ invo
Candidate:	token::div:
      __ invo
Candidate:	token::mod:
      __ invo
Candidate:	token::bit_or:
      __ i
Candidate:	token::bit_and:
      __ 
Candidate:	token::bit_xor:
      __ 
Candidate:	token::sar:
      __ invo
Candidate:	token::shl:
      __ invo
Candidate:	token::shr:
      __ invo
Candidate:	token::value op,
        
Candidate:	token(masm_, token::strin
Candidate:	token::string(op));
  swi
Candidate:	token::add:
    case toke
Candidate:	token::sub:
    case toke
Candidate:	token::mul:
    case toke
Candidate:	token::div:
    case toke
Candidate:	token::mod: {
      gener
Candidate:	token::bit_or:
    case t
Candidate:	token::bit_and:
    case 
Candidate:	token::bit_xor: {
      l
Candidate:	token::bit_or:  __ or_(ea
Candidate:	token::bit_and: __ and_(e
Candidate:	token::bit_xor: __ xor_(e
Candidate:	token::shl:
    case toke
Candidate:	token::shr:
    case toke
Candidate:	token::sar: {
      label
Candidate:	token::sar:
          __ 
Candidate:	token::shr:
          __ 
Candidate:	token::shl:
          __ 
Candidate:	token::comma: {
      // 
Candidate:	token::value op, int valu
Candidate:	token::value op_;
  int v
Candidate:	token::value op, int valu
Candidate:	token::value op_;
  int v
Candidate:	token::add, overwrite_mod
Candidate:	token::add, overwrite_mod
Candidate:	token::sub, overwrite_mod
Candidate:	token::sub, overwrite_mod
Candidate:	token::value op,
        
Candidate:	token::add: {
      defer
Candidate:	token::sub: {
      defer
Candidate:	token::sar: {
      if (r
Candidate:	token::sar, shift_value,

Candidate:	token::shr: {
      if (r
Candidate:	token::shr, shift_value,

Candidate:	token::shl: {
      if (r
Candidate:	token::shl, shift_value,

Candidate:	token::bit_or:
    case t
Candidate:	token::bit_xor:
    case 
Candidate:	token::bit_and: {
      d
Candidate:	token::bit_and) {
       
Candidate:	token::bit_xor) {
       
Candidate:	token::bit_or);
        _
Candidate:	token::assign ||
      no
Candidate:	token::init_var ||
      
Candidate:	token::init_const) {
    
Candidate:	token::init_var && node->
Candidate:	token::init_const) {
    
Candidate:	token::init_const) {
    
Candidate:	token::value op = node->o
Candidate:	token::not) {
    loadcon
Candidate:	token::delete) {
    prop
Candidate:	token::typeof) {
    // s
Candidate:	token::not:
      case to
Candidate:	token::delete:
      case
Candidate:	token::typeof:
        un
Candidate:	token::sub: {
        una
Candidate:	token::bit_not: {
       
Candidate:	token::void:
        __ m
Candidate:	token::add: {
        // 
Candidate:	token::inc;

  variable* 
Candidate:	token::value op = node->o
Candidate:	token::and) {
    label i
Candidate:	token::or) {
    label is
Candidate:	token::value op = node->o
Candidate:	token::eq || op == token:
Candidate:	token::eq_strict) {
    /
Candidate:	token::eq_strict) {
     
Candidate:	token::eq || op == token:
Candidate:	token::eq_strict) &&
    
Candidate:	token::typeof) &&
      (
Candidate:	token::eq_strict:
      s
Candidate:	token::eq:
      cc = equ
Candidate:	token::lt:
      cc = les
Candidate:	token::gt:
      cc = gre
Candidate:	token::lte:
      cc = le
Candidate:	token::gte:
      cc = gr
Candidate:	token::in: {
      load(l
Candidate:	token::instanceof: {
    
Candidate:	keyed = 2 };
  reference(
Candidate:	key,
                    
Candidate:	key(variable->name());
  
Candidate:	key, knoposition);
    lo
Candidate:	key is a literal symbol.

Candidate:	key is a string that can 
Candidate:	key()->asliteral();
    u
Candidate:	key());
      ref->set_ty
Candidate:	keyed);
    }
  } else if
Candidate:	key() { return toboolean;
Candidate:	key() { return 0; }

  co
Candidate:	key,
    codegenstate::ac
Candidate:	key->asliteral();
    han
Candidate:	keyed property.
    asser
Candidate:	keyed);

    if (is_load)
Candidate:	keyedloadic_initialize));
Candidate:	keyedstoreic_initialize))
Candidate:	key encoding in 16 bits o
Candidate:	key() { return genericbin
Candidate:	key() {
    // encode the
Candidate:	key() { return argumentsa
Candidate:	key() { return is_length_
Candidate:	key is a smi for non-leng
Candidate:	key() { return compare; }
Candidate:	key() {
    // encode the
Candidate:	key() { return callfuncti
Candidate:	key() { return argc_; }
}
Candidate:	key and kjs ignore null a
Candidate:	key.
  // eax: current it
Candidate:	key, call_function);
  __
Candidate:	key(property->key()->hand
Candidate:	key()->handle());
       
Candidate:	key->issymbol()) {
      
Candidate:	key));
          __ call(
Candidate:	key());
        load(prop
Candidate:	key());
        __ push(i
Candidate:	key());
        __ push(i
Candidate:	key(), access());
  } els
Candidate:	key is a literal string.

Candidate:	key()->asliteral();

    
Candidate:	key"](1, 2, 3)'
      // 
Candidate:	key onto the stack and se
Candidate:	key].
  argumentsaccessst
Candidate:	key());
      __ invokebu
Candidate:	key() { return reverttonu
Candidate:	key() { return is_increme
Candidate:	key() { return counterop;
Candidate:	key() {
    return ((resu
Candidate:	token_position,
         
Candidate:	token_position(function_t
Candidate:	token_position);
  fun->s
Candidate:	token_position(),
       
Candidate:	token_position,
         
Candidate:	key(int minor_key) {
    
Candidate:	key) {
    return runtime
Candidate:	key))->stub_name;
  }

 p
Candidate:	key() { return runtime; }
Candidate:	key() {
    return idfiel
Candidate:	key() { return stackcheck
Candidate:	key() { return 0; }
};



Candidate:	key() { return unarysub; 
Candidate:	key() { return 0; }
  voi
Candidate:	key() { return centry; }

Candidate:	key() { return 0; }

  co
Candidate:	key() { return 1; }

  co
Candidate:	key() { return jsentry; }
Candidate:	key() { return 0; }

  co
Candidate:	key() { return 1; }

  co
Candidate:	key into the arguments ob
Candidate:	api function flushinstruc
Candidate:	key.
      var time = top
Candidate:	keywordtable::kprefixleng
	KEY FOUND:	keywordtable::kprefixleng
Candidate:	keywordtable::kprefixleng
	KEY FOUND:	keywordtable::kprefixleng
Candidate:	keywordtable::lookup(pre,
Candidate:	keywordtype type = keywor
Candidate:	keywordtable::gettype(ind
Candidate:	keywordtable::getvalue(in
Candidate:	keywordtable::getvalue(in
Candidate:	keywordtable::getvalue(in
Candidate:	keywordtable::array[][dat
Candidate:	keywordtable::kentrysize]
Candidate:	keywordtable::lookup(cons
Candidate:	keyword is only allowed f
Candidate:	keywordtype { invalid, mo
Candidate:	keywordtable maps names o
Candidate:	keywordtable : public all
Candidate:	keyword table and return 
Candidate:	keyword at index i.
    s
Candidate:	keywordtype gettype(int i
Candidate:	keywordtype>(array[i][kty
Candidate:	keyword at index i.
    s
Candidate:	api include file debug.h.
Candidate:	key in object) {
    // o
Candidate:	keys.
    if (typeof key 
Candidate:	key == 'string') {
      
Candidate:	key];

      // format th
Candidate:	key) + ':' + property_val
Candidate:	api.h"
#include "argument
Candidate:	api.  messages are
// kep
Candidate:	api_event_data =
      v8
Candidate:	api_event_data->get(fun_n
Candidate:	api_event_data, 0, null);
Candidate:	api_exec_state =
      v8
Candidate:	api_exec_state->get(fun_n
Candidate:	api_exec_state, 0, null))
Candidate:	api on the queue.  create
Candidate:	api client.  called
// by
Candidate:	api client thread.  this 
Candidate:	api client hands off
// p
Candidate:	key = factory::lookupasci
Candidate:	key, handle<object>(globa
Candidate:	key is a possible break
/
Candidate:	key = code->major_key();

Candidate:	key();
  return major_key
Candidate:	key == codestub::callfunc
Candidate:	key is a possible break
/
Candidate:	key = code->major_key();

Candidate:	key();
  return major_key
Candidate:	key == codestub::callfunc
Candidate:	key == codestub::stackche
Candidate:	keyed_load_stub()) {
    
Candidate:	keyedloadic_debugbreak));
Candidate:	keyed_store_stub()) {
   
Candidate:	keyedstoreic_debugbreak))
Candidate:	key() == codestub::callfu
Candidate:	key() == codestub::stackc
Candidate:	api thread.
  virtual ~de
Candidate:	api.
  void sendmessage(v
Candidate:	api on the queue.  called
Candidate:	api client thread.  this 
Candidate:	api client hands off
  //
Candidate:	key is a possible break
 
Candidate:	key cannot be retrieved
 
Candidate:	key and extract major and
Candidate:	key.
              uint32
Candidate:	key = smi::cast(obj)->val
Candidate:	key = codestub::minorkeyf
Candidate:	keyfromkey(key);
        
Candidate:	key(key);
              a
Candidate:	key);
              asser
Candidate:	key() == codestub::majork
Candidate:	keyfromkey(key));
       
Candidate:	key(key));
              
Candidate:	key));
              out.
Candidate:	key()));
              sw
Candidate:	key()) {
                
Candidate:	key);
                  b
Candidate:	key(minor_key);
         
Candidate:	key);
                  o
Candidate:	key);
              }
   
Candidate:	api.h"
#include "codegen-
Candidate:	api can have an instance-
Candidate:	key does.
  if (flag_call
Candidate:	api.h"
#include "debug.h"
Candidate:	apifunction(
    handle<f
Candidate:	apicall));

  int interna
Candidate:	key,
    handle<object> v
Candidate:	key, *value, attributes);
Candidate:	key, *value, attributes);
Candidate:	key is a symbol before wr
Candidate:	key =
        symbolfroms
Candidate:	key, 0, descriptor_count 
Candidate:	key, *entry, entry->prope
Candidate:	key,
                    
Candidate:	key, *value), dictionary)
Candidate:	api to create env-indepen
Candidate:	apifunction(handle<functi
Candidate:	keys in the sourcecodecac
Candidate:	key,
      handle<object>
Candidate:	key,
                    
Candidate:	tokenifchanged(function);
Candidate:	api.h"
#include "global-h
Candidate:	api<v8::object>(handle())
Candidate:	api functions.
  // at th
Candidate:	api header files when mix
Candidate:	api.h"

namespace v8 { na
Candidate:	api.h"
#include "bootstra
Candidate:	apiobjectaccess("intercep
Candidate:	apiobjectaccess("intercep
Candidate:	keysfromjsarray(handle<fi
Candidate:	keysfromjsarray(*array), 
Candidate:	keys(handle<fixedarray> f
Candidate:	keys(*second), fixedarray
Candidate:	key,
                 han
Candidate:	key, *value, attributes))
Candidate:	key,
                    
Candidate:	key, *value, attributes),
Candidate:	key,
                    
Candidate:	key, value, attributes),

Candidate:	key,
                    
Candidate:	key,
                    
Candidate:	key) {
  call_heap_functi
Candidate:	key), object);
}


handle
Candidate:	keys from the interceptor
Candidate:	keysfornamedinterceptor(h
Candidate:	keys from the interceptor
Candidate:	keysforindexedinterceptor
Candidate:	keysinfixedarrayfor(handl
Candidate:	keys)) {
    top::reportf
Candidate:	keys);
    return content
Candidate:	keys if access is permitt
Candidate:	keys.
      content = uni
Candidate:	keys(content, getenumprop
Candidate:	keys(current));

      //
Candidate:	keys from the interceptor
Candidate:	keysfornamedinterceptor(o
Candidate:	keysfromjsarray(content, 
Candidate:	keys.
      handle<fixeda
Candidate:	keys =
          factory:
Candidate:	keys(*element_keys);
    
Candidate:	keys);
      content = un
Candidate:	keys(content, element_key
Candidate:	keys);

      // add the 
Candidate:	keys from the interceptor
Candidate:	keysforindexedinterceptor
Candidate:	keysfromjsarray(content, 
Candidate:	keysfor(handle<jsobject> 
Candidate:	keysinfixedarrayfor(objec
Candidate:	keys(handle<jsobject> obj
Candidate:	key());
        (*sort_ar
Candidate:	keysto(*storage, *sort_ar
Candidate:	api.h.
  inline handle<t>
Candidate:	key,
                 han
Candidate:	key,
                    
Candidate:	key,
                    
Candidate:	key,
                    
Candidate:	key);

handle<object> get
Candidate:	keys from interceptors. u
Candidate:	keysinfixedarrayfor below
Candidate:	keysfornamedinterceptor(h
Candidate:	keysforindexedinterceptor
Candidate:	keys for a jsobject. used
Candidate:	keysinfixedarrayfor(handl
Candidate:	keysfor(handle<jsobject> 
Candidate:	keys(handle<jsobject> obj
Candidate:	keys and return the resul
Candidate:	keys(handle<fixedarray> f
Candidate:	key, uint32_t hash, bool 
Candidate:	key, hash);
    if (p->ke
Candidate:	key != null) {
    return
Candidate:	key = key;
    p->value =
Candidate:	key;
    p->value = null;
Candidate:	key, hash);
    }

    re
Candidate:	key = null;
  }
  occupan
Candidate:	key != null) {
      retu
Candidate:	key, uint32_t hash) {
  a
Candidate:	key != null);

  assert(i
Candidate:	key != null && (hash != p
Candidate:	key, p->key))) {
    p++;
Candidate:	key))) {
    p++;
    if 
Candidate:	key != null) {
      look
Candidate:	key, p->hash, true)->valu
Candidate:	key1, void* key2);

  // 
Candidate:	key2);

  // dummy constr
Candidate:	key, value, hash) tripple
Candidate:	key is the value).
  stru
Candidate:	key;
    void* value;
   
Candidate:	key
  };

  // if an entr
Candidate:	key is found, lookup()
  
Candidate:	key, key hash, and null v
Candidate:	key hash, and null value.
Candidate:	key, uint32_t hash, bool 
Candidate:	key, uint32_t hash);
  vo
Candidate:	api.h"
#include "bootstra
Candidate:	apiobjects() {
  object* 
Candidate:	api until it is setup.
st
Candidate:	api, we should gracefully
Candidate:	api), configure it.
  // 
Candidate:	apiobjects()) return fals
Candidate:	apiterator::heapiterator(
Candidate:	apiterator() {
  init();

Candidate:	apiterator::~heapiterator
	KEY FOUND:	apiterator::~heapiterator
Candidate:	apiterator() {
  shutdown
Candidate:	apiterator::init() {
  //
Candidate:	apiterator::shutdown() {

Candidate:	apiterator::has_next() {

Candidate:	apiterator::next() {
  if
Candidate:	apiterator::reset() {
  /
Candidate:	apiterator iterator;
  wh
Candidate:	key = number_string_cache
Candidate:	key == number) {
    retu
Candidate:	key->isheapnumber() &&
  
Candidate:	key->number() == number->
Candidate:	api.
  //

  static bool 
Candidate:	apiobjects();

  // attem
Candidate:	api kept alive
  // by gl
Candidate:	apiterator provides itera
Candidate:	apiterator base_embedded 
Candidate:	apiterator();
  virtual ~
Candidate:	apiterator();

  bool has
Candidate:	key is identical to the n
Candidate:	keyed load/store is not i
Candidate:	keyedloadic::generatemiss
	KEY FOUND:	keyedloadic::generatemiss
Candidate:	keyedloadic::generate(mac
Candidate:	keyedloadic::generategene
	KEY FOUND:	keyedloadic::generategene
Candidate:	keyedstoreic::generate(ma
Candidate:	keyedstoreic::generategen
	KEY FOUND:	keyedstoreic::generategen
Candidate:	key is identical to the n
Candidate:	keyedloadic::generategene
	KEY FOUND:	keyedloadic::generategene
Candidate:	key is a smi.
  __ test(e
Candidate:	key (index) is within bou
Candidate:	keyed_load_generic_slow, 
Candidate:	keyedloadic::generate(mas
Candidate:	key is a symbol that is n
Candidate:	keyed_load_generic_symbol
Candidate:	keyed_load_generic_smi, 1
Candidate:	keyedstoreic::generategen
	KEY FOUND:	keyedstoreic::generategen
Candidate:	key
  //  -- esp[8] : rec
Candidate:	key and the object from t
Candidate:	key
  // check that the k
Candidate:	key is a smi.
  __ test(e
Candidate:	key against length in the
Candidate:	key (for checking against
Candidate:	key against the length in
Candidate:	keyedloadic_miss(argument
Candidate:	keyedloadic::generatemiss
	KEY FOUND:	keyedloadic::generatemiss
Candidate:	keyedloadic_miss)));
}



Candidate:	keyedloadic::generate(mac
Candidate:	keyedstoreic_miss(argumen
Candidate:	keyedstoreic::generate(ma
Candidate:	key
  //  -- esp[8] : rec
Candidate:	api.h"
#include "argument
Candidate:	keyed load/store, the mos
Candidate:	key has changed.  we do n
Candidate:	keyed access.
    code::k
Candidate:	keyed_load_ic || kind == 
Candidate:	keyed_store_ic) {
      r
Candidate:	keyed_load_ic: return key
Candidate:	keyedloadic::clear(addres
Candidate:	keyed_store_ic: return ke
Candidate:	keyedstoreic::clear(addre
Candidate:	keyedloadic::clear(addres
Candidate:	keyedstoreic::clear(addre
Candidate:	keyedloadic::load(state s
Candidate:	key) {
  if (key->issymbo
Candidate:	key->issymbol()) {
    ha
Candidate:	key);

    // if the obje
Candidate:	keyedloadshortstringlengt
Candidate:	keyedloadmediumstringleng
Candidate:	keyedloadlongstringlength
Candidate:	keyedloadic", name, state
Candidate:	keyedloadarraylength(*nam
Candidate:	keyedloadic", name, state
Candidate:	keyedloadfunctionprototyp
Candidate:	keyedloadic", name, state
Candidate:	keyed load stub.
      if
Candidate:	key);
}


void keyedloadi
Candidate:	keyedloadic::updatecaches
	KEY FOUND:	keyedloadic::updatecaches
Candidate:	keyedloadfield(*name, *re
Candidate:	keyedloadconstant(*name, 
Candidate:	keyedloadcallback(*name, 
Candidate:	keyedloadinterceptor(*nam
Candidate:	keyedloadic", name, state
Candidate:	keyedstoreic::store(state
Candidate:	key,
                    
Candidate:	key->issymbol()) {
    ha
Candidate:	key);

    // if the obje
Candidate:	key, value, none);
}


vo
Candidate:	keyedstoreic::updatecache
	KEY FOUND:	keyedstoreic::updatecache
Candidate:	keyedstorefield(*name, *r
Candidate:	keyedstorefield(*name, *r
Candidate:	keyedstoreic", name, stat
Candidate:	keyedloadic_miss(argument
Candidate:	keyedloadic ic;
  ic::sta
Candidate:	keyedloadic::generateinit
	KEY FOUND:	keyedloadic::generateinit
Candidate:	keyedloadic_miss)));
}



Candidate:	keyedloadic::generateprem
	KEY FOUND:	keyedloadic::generateprem
Candidate:	keyedloadic_miss)));
}



Candidate:	keyedstoreic_miss(argumen
Candidate:	keyedstoreic ic;
  ic::st
Candidate:	keyedstoreic::generateini
	KEY FOUND:	keyedstoreic::generateini
Candidate:	keyedstoreic_miss)));
}


Candidate:	keyedstoreic::generatemis
	KEY FOUND:	keyedstoreic::generatemis
Candidate:	keyedstoreic_miss)));
}


Candidate:	keyedloadic_miss)        
Candidate:	keyedstoreic_miss)       
Candidate:	keyedloadic: public ic {

Candidate:	keyedloadic() : ic(no_ext
Candidate:	keyed_load_stub()); }

  
Candidate:	key);

  // code generato
Candidate:	keyedloadic_initialize);

Candidate:	keyedloadic_generic);
  }
Candidate:	keyedloadic_generic);
  }
Candidate:	keyedloadic_premonomorphi
Candidate:	keyedstoreic: public ic {
Candidate:	keyedstoreic() : ic(no_ex
Candidate:	keyedstoreic_initialize);
Candidate:	keyedstoreic_generic);
  
Candidate:	keyedstoreic_generic);
  
Candidate:	api, code, gc, suspect, o
Candidate:	api, false, "log api even
Candidate:	api events to the log fil
Candidate:	apievent is private so al
Candidate:	api is true.
void logger:
Candidate:	apievent(const char* form
Candidate:	api);
  scopedlock sl(mut
Candidate:	apinamedsecuritycheck(obj
Candidate:	api) return;
  if (key->i
Candidate:	apievent("api,check-secur
Candidate:	api,check-security,\"%s\"
Candidate:	apievent("api,check-secur
Candidate:	api,check-security,undefi
Candidate:	apievent("api,check-secur
Candidate:	api,check-security,['no-n
Candidate:	apiindexedsecuritycheck(u
Candidate:	api) return;
  apievent("
Candidate:	apievent("api,check-secur
Candidate:	api,check-security,%u\n",
Candidate:	apinamedpropertyaccess(co
Candidate:	api) return;
  string* cl
Candidate:	apievent("api,%s,\"%s\",\
Candidate:	api,%s,\"%s\",\"%s\"\n", 
Candidate:	apiindexedpropertyaccess(
Candidate:	api) return;
  string* cl
Candidate:	apievent("api,%s,\"%s\",%
Candidate:	api,%s,\"%s\",%u\n", tag,
Candidate:	apiobjectaccess(const cha
Candidate:	api) return;
  string* cl
Candidate:	apievent("api,%s,\"%s\"\n
Candidate:	api,%s,\"%s\"\n", tag, *c
Candidate:	apientrycall(const char* 
Candidate:	api) return;
  logger::ap
Candidate:	apievent("api,%s\n", name
Candidate:	api,%s\n", name);
#endif

Candidate:	api = true;
    flag_log_
Candidate:	api || flag_log_code || f
Candidate:	key) {
#ifdef enable_logg
Candidate:	key->isstring()) {
    sm
Candidate:	key)->tocstring(disallow_
Candidate:	key->isundefined()) {
   
Candidate:	api, code, or gc sample e
Candidate:	api, --log-code, and --lo
Candidate:	api
// log api events to 
Candidate:	api events to the logfile
Candidate:	api implies --log.
//
// 
Candidate:	api. ====
  static void a
Candidate:	apinamedsecuritycheck(obj
Candidate:	apiindexedsecuritycheck(u
Candidate:	apinamedpropertyaccess(co
Candidate:	apiindexedpropertyaccess(
Candidate:	apiobjectaccess(const cha
Candidate:	apientrycall(const char* 
Candidate:	apievent(const char* name
Candidate:	key);
  static void apiin
Candidate:	token in the calling glob
Candidate:	token in the receiving gl
Candidate:	tokenoffset));
  ldr(ip, 
Candidate:	tokenoffset));
  cmp(scra
Candidate:	token in the calling glob
Candidate:	token in the receiving gl
Candidate:	tokenoffset));
  cmp(scra
Candidate:	tokenoffset));
  j(not_eq
Candidate:	key encoding in 12 bits o
Candidate:	key() { return recordwrit
Candidate:	key() {
    // encode the
Candidate:	keyedstoreic::generategen
	KEY FOUND:	keyedstoreic::generategen
Candidate:	api.h"
#include "executio
Candidate:	api_message_obj = v8::uti
Candidate:	api_message_obj, v8::util
Candidate:	apitalvowelsounds = {a: t
Candidate:	apitalvowelsounds;
  }
  
Candidate:	token:             "unexp
Candidate:	token %0",
  unexpected_t
Candidate:	token_number:      "unexp
Candidate:	token_string:      "unexp
Candidate:	token_identifier:  "unexp
Candidate:	api. a non native accesso
Candidate:	apiterator;
static counte
Candidate:	token position = %d", fun
Candidate:	token_position());
  prin
Candidate:	key()->stringprint();
   
Candidate:	keyat(i);
    if (iskey(k
Candidate:	key(k)) {
      printf(" 
Candidate:	key = null;
  uint32_t cu
Candidate:	key = r.getkey();
    if 
Candidate:	key();
    if (key == cur
Candidate:	key == current_key) {
   
Candidate:	key) {
      printdescrip
Candidate:	key = key;
    uint32_t h
Candidate:	key;
    uint32_t hash = 
Candidate:	key()->hash();
    if (ha
Candidate:	token, object, ksecurityt
Candidate:	tokenoffset)

accessors(a
Candidate:	token_position,
         
Candidate:	tokenpositionoffset)


in
Candidate:	key) {
  propertyattribut
Candidate:	key, &attributes);
}


ob
Candidate:	key, propertyattributes* 
Candidate:	key, attributes);
}


#de
Candidate:	key(number)) return numbe
Candidate:	key(int descriptor_number
Candidate:	keyindex(descriptor_numbe
Candidate:	key(descriptor_number),
 
Candidate:	key()));
  assert(!heap::
Candidate:	keyindex(descriptor_numbe
Candidate:	key());
  fixedarray* con
Candidate:	keyindex(first), tokeyind
Candidate:	keyindex(second));
  fixe
Candidate:	key() {
  assert(!require
Candidate:	key() {
  assert(kind() =
Candidate:	keyoffset));
}


void cod
Candidate:	key(codestub::major major
Candidate:	keyoffset, major);
}


bo
Candidate:	key) {
  return getproper
Candidate:	key);
}


bool jsobject::
Candidate:	key,
                    
Candidate:	key->isstring() || detail
Candidate:	key, mode);
  set(index+1
Candidate:	api.h"
#include "bootstra
Candidate:	api we switch on the
  //
Candidate:	api style callbacks.
  if
Candidate:	apinamedpropertyaccess("l
Candidate:	api accessors.
        ob
Candidate:	apital letter.  the a/an 
Candidate:	apiteratebody(v);
      b
Candidate:	apinamedpropertyaccess("i
Candidate:	api we switch on the
  //
Candidate:	api style callbacks
    a
Candidate:	apinamedpropertyaccess("s
Candidate:	apinamedpropertyaccess("i
Candidate:	apinamedpropertyaccess("i
Candidate:	apinamedpropertyaccess("i
Candidate:	apiindexedpropertyaccess(
Candidate:	apiteratebody(objectvisit
Candidate:	apiindexedpropertyaccess(
Candidate:	apiindexedpropertyaccess(
Candidate:	apiindexedpropertyaccess(
Candidate:	apiindexedpropertyaccess(
Candidate:	apinamedpropertyaccess("i
Candidate:	key(name);
    handle<obj
Candidate:	key), info);
    }
    re
Candidate:	key(name);
    handle<obj
Candidate:	key),
               v8::
Candidate:	key(name);
      handle<o
Candidate:	key, holder_handle };
   
Candidate:	key) {
  uint32_t index;

Candidate:	key->asarrayindex(&index)
Candidate:	key, &result);
  return g
Candidate:	key, true);
}


propertya
Candidate:	key(), value, d);
       
Candidate:	key(), value, d);
       
Candidate:	key(), value, d);
       
Candidate:	key = slowreverselookup(o
Candidate:	key != heap::undefined_va
Candidate:	key = element_dictionary(
Candidate:	key != heap::undefined_va
Candidate:	key();
        }
      } 
Candidate:	key();
        }
      }

Candidate:	key = cache->get(i);
    
Candidate:	key->isundefined()) {
   
Candidate:	key))) {
      code::flag
Candidate:	key = cache->get(i);
    
Candidate:	key->isundefined()) {
   
Candidate:	key;
    }
    if (name->
Candidate:	key))) {
      code* code
Candidate:	key(fixedarray* array, ob
Candidate:	key) {
  int len0 = array
Candidate:	key->issmi() && (element 
Candidate:	key)) return true;
    if
Candidate:	key->isstring() && string
Candidate:	key))) {
      return tru
Candidate:	keysfromjsarray(jsarray* 
Candidate:	key_array = fixedarray::c
Candidate:	key_array->set(i, compact
Candidate:	keys(key_array);
}


obje
Candidate:	key_array);
}


object* f
Candidate:	keys(fixedarray* other) {
Candidate:	key(this, other->get(y)))
Candidate:	keys.
  int index = 0;
  
Candidate:	key(this, other->get(y)))
Candidate:	keys.
  object* array = h
Candidate:	keyindex(number_of_descri
Candidate:	key is a symbol.
  object
Candidate:	keytosymbol();
  if (resu
Candidate:	key is in descriptor, we 
Candidate:	key());
  const bool inse
Candidate:	key()->hash();

  for (; 
Candidate:	key()->hash() > descripto
Candidate:	key() == descriptor->getk
Candidate:	key()) break;
    if (r.i
Candidate:	key() == descriptor->getk
Candidate:	key());
    r.advance();

Candidate:	key()->hash() > descripto
Candidate:	key() != name) {  // both
Candidate:	key(parent_index)->hash()
Candidate:	key(child_index)->hash();
Candidate:	key(child_index)->hash();
Candidate:	key(child_index + 1)->has
Candidate:	key(parent_index)->hash()
Candidate:	key(mid);
    uint32_t mi
Candidate:	key(mid - 1)->hash() == h
Candidate:	key(mid)->hash() == hash)
Candidate:	key(mid)->equals(name)) r
Candidate:	keyed_load_ic: return "ke
Candidate:	keyed_load_ic";
    case 
Candidate:	keyed_store_ic: return "k
Candidate:	keyed_store_ic";
    case
Candidate:	key = dictionary->keyat(i
Candidate:	keyat(i);
      if (key->
Candidate:	key->isnumber()) {
      
Candidate:	key->number());
        e
Candidate:	key() + 1;
    }
    obje
Candidate:	key();
  }
  return stati
Candidate:	keyat(i);
    if (iskey(k
Candidate:	key(k)) {
      dict->add
Candidate:	keyat(i);
    if (iskey(k
Candidate:	key(k)) elements->set(pos
Candidate:	key) {
  // check access 
Candidate:	key, v8::access_has)) {
 
Candidate:	key, &result);
  if (resu
Candidate:	key) {
  // check access 
Candidate:	key, v8::access_has)) {
 
Candidate:	key, &result);
  return r
Candidate:	key());
      }
    }
   
Candidate:	keysto(storage);
  }
}



Candidate:	keys(null, filter);
}


i
Candidate:	keys(fixedarray* storage,
Candidate:	keysto(storage, filter);

Candidate:	keys(fixedarray* storage)
Candidate:	keys(storage,
           
Candidate:	key uses carries the uint
Candidate:	key.
// this avoids alloc
Candidate:	key : public dictionary::
Candidate:	key {
 public:
  explicit
Candidate:	key(uint32_t number) {
  
Candidate:	key) {
    uint32_t hash 
Candidate:	key;
    hash = ~hash + (
Candidate:	key() { return false; }


Candidate:	key simply carries a stri
Candidate:	key.
class dictionary::st
Candidate:	key : public dictionary::
Candidate:	key {
 public:
  explicit
Candidate:	key(string* string) {
   
Candidate:	key() { return true; }

 
Candidate:	key carries a vector of c
Candidate:	key.
class symboltable::u
Candidate:	key : public symboltable:
Candidate:	key {
 public:
  explicit
Candidate:	key(vector<const char> st
Candidate:	key() { return true; }

 
Candidate:	key carries a string obje
Candidate:	key.
class symboltable::s
Candidate:	key : public symboltable:
Candidate:	key {
 public:
  explicit
Candidate:	key(string* string) : str
Candidate:	key() { return true; }

 
Candidate:	key otherwise return -1.

Candidate:	key* key) {
  uint32_t no
Candidate:	key) {
  uint32_t nof = n
Candidate:	key->hash();
  uint32_t e
Candidate:	keyat(entry);
  uint32_t 
Candidate:	key->ismatch(element)) re
Candidate:	keyat(entry);
    if (!el
Candidate:	key->ismatch(element)) re
Candidate:	key* key) {
  int capacit
Candidate:	key) {
  int capacity = c
Candidate:	key) = key->gethashfuncti
Candidate:	key->gethashfunction();
 
Candidate:	key = get(from_index);
  
Candidate:	key(key)) {
      uint32_
Candidate:	key)) {
      uint32_t in
Candidate:	key, hash(key)));
      f
Candidate:	key)));
      for (int j 
Candidate:	key,
      uint32_t hash)
Candidate:	keyat(entry);

  for (uin
Candidate:	keyat(entry);
  }

  retu
Candidate:	key key(string);
  return
Candidate:	key(string);
  return loo
Candidate:	key(&key, s);
}


object*
Candidate:	key, s);
}


object* symb
Candidate:	key key(str);
  return lo
Candidate:	key(str);
  return lookup
Candidate:	key(&key, s);
}


object*
Candidate:	key, s);
}


object* symb
Candidate:	key(key* key, object** s)
Candidate:	key* key, object** s) {
 
Candidate:	key, object** s) {
  int 
Candidate:	key);

  // symbol alread
Candidate:	keyat(entry);
    return 
Candidate:	key);
  if (obj->isfailur
Candidate:	key->getobject();
  if (s
Candidate:	key->hash());
  table->se
Candidate:	key(keyat(i))) {
      en
Candidate:	keyat(i))) {
      enumer
Candidate:	key(keyat(i))) {
      in
Candidate:	keyat(i))) {
      int en
Candidate:	key* key) {
  // check wh
Candidate:	key) {
  // check whether
Candidate:	key->isstringkey() &&
   
Candidate:	key() &&
      !propertyd
Candidate:	key);
}


void dictionary
Candidate:	key = keyat(i);
    if (k
Candidate:	keyat(i);
    if (key->is
Candidate:	key->isnumber()) {
      
Candidate:	key->number());
      if 
Candidate:	key) {
  stringkey k(key)
Candidate:	key k(key);
  return find
Candidate:	key);
  return findentry(
Candidate:	key k(index);
  return fi
Candidate:	key* key, object* value) 
Candidate:	key, object* value) {
  i
Candidate:	key);

  // if the entry 
Candidate:	key);
  if (obj->isfailur
Candidate:	key->getobject();
  if (k
Candidate:	key->hash());
  return ob
Candidate:	key* key, object* value, 
Candidate:	key, object* value, prope
Candidate:	key);
  if (obj->isfailur
Candidate:	key object.
  object* k =
Candidate:	key->getobject();
  if (k
Candidate:	key->hash());
  return ob
Candidate:	key, value pair to the di
Candidate:	key,
                    
Candidate:	key, hash);
  // insert e
Candidate:	key->isstring()) {
    //
Candidate:	key, value, details);
  a
Candidate:	keyat(entry)->isnumber() 
Candidate:	keyat(entry)->isstring())
Candidate:	key(uint32_t key) {
  // 
Candidate:	key) {
  // if the dictio
Candidate:	key > krequiresslowelemen
Candidate:	key value.
  object* max_
Candidate:	key() < key) {
    set(kp
Candidate:	key) {
    set(kprefixsta
Candidate:	key << krequiressloweleme
Candidate:	key,
                    
Candidate:	key k(key);
  slow_assert
Candidate:	key);
  slow_assert(finde
Candidate:	key,
                    
Candidate:	key k(key);
  updatemaxnu
Candidate:	key);
  updatemaxnumberke
Candidate:	key(key);
  slow_assert(f
Candidate:	key);
  slow_assert(finde
Candidate:	key, object* value) {
  s
Candidate:	key k(key);
  return atpu
Candidate:	key);
  return atput(&k, 
Candidate:	key, object* value) {
  n
Candidate:	key k(key);
  updatemaxnu
Candidate:	key);
  updatemaxnumberke
Candidate:	key(key);
  return atput(
Candidate:	key);
  return atput(&k, 
Candidate:	key,
                    
Candidate:	key k(key);
  int entry =
Candidate:	key);
  int entry = finde
Candidate:	key, value, details);
  /
Candidate:	key, value, details);
  r
Candidate:	keyat(i);
    if (iskey(k
Candidate:	key(k)) {
      propertya
Candidate:	keysto(fixedarray* storag
Candidate:	keyat(i);
     if (iskey(
Candidate:	key(k)) {
       property
Candidate:	keysto(fixedarray* storag
Candidate:	keyat(i);
     if (iskey(
Candidate:	key(k)) {
       property
Candidate:	keysto(fixedarray* storag
Candidate:	keyat(i);
    if (iskey(k
Candidate:	key(k)) {
      storage->
Candidate:	keyat(i);
    if (iskey(k
Candidate:	key(k) && valueat(i) == v
Candidate:	keyat(i);
    if (iskey(k
Candidate:	key(k)) {
      object* v
Candidate:	keyat(i);
    if (iskey(k
Candidate:	key(k)) {
      object* v
Candidate:	key is a symbol before wr
Candidate:	key = heap::lookupsymbol(
Candidate:	key->isfailure()) return 
Candidate:	key;
      propertydetail
Candidate:	key),
                   
Candidate:	key),
                   
Candidate:	key),
                   
Candidate:	api (needed for correct i
Candidate:	apiteratebody(objectvisit
Candidate:	api.
  // in the long run
Candidate:	api expects that all exte
Candidate:	api.  therefore, external
Candidate:	token in the script sourc
Candidate:	token_position();
  inlin
Candidate:	token_position(int functi
Candidate:	token_position);

  // po
Candidate:	tokenpositionoffset = ken
Candidate:	tokenpositionoffset + kin
Candidate:	token]: the object being 
Candidate:	token, object)

  // cast
Candidate:	tokenoffset = globalobjec
Candidate:	tokenoffset + kpointersiz
Candidate:	key);
  inline object* ge
Candidate:	key, propertyattributes* 
Candidate:	key,
                    
Candidate:	key,
                    
Candidate:	key,
                    
Candidate:	key,
                    
Candidate:	key,
                    
Candidate:	key);
  bool hasrealeleme
Candidate:	key);

  // initializes t
Candidate:	keys(fixedarray* storage,
Candidate:	keys(fixedarray* storage)
Candidate:	keysfromjsarray(jsarray* 
Candidate:	keys(fixedarray* other);

Candidate:	key
//   [length() - 1]: 
Candidate:	key
//
class descriptorar
Candidate:	key(int descriptor_number
Candidate:	key name
  // removed.  i
Candidate:	keys.
  void sort();

  /
Candidate:	key was not found.
  stat
Candidate:	keyindex(int descriptor_n
Candidate:	key == undefined have not
Candidate:	key == null have been del
Candidate:	key size, of the elements
Candidate:	key at entry.
  object* k
Candidate:	keyat(int entry) { return
Candidate:	key.  null and undefined 
Candidate:	keys and can be used to i
Candidate:	key(object* k) {
    retu
Candidate:	key is an abstract superc
Candidate:	keys.
  class key {
   pu
Candidate:	key {
   public:
    // r
Candidate:	key.
    virtual bool ism
Candidate:	key.
    virtual hashfunc
Candidate:	key.
    virtual uint32_t
Candidate:	key object for storing in
Candidate:	key() = 0;
    // require
Candidate:	key() {}
  };

  // compu
Candidate:	key otherwise return -1.

Candidate:	key* key);

  // find the
Candidate:	key);

  // find the entr
Candidate:	key that
  // has the giv
Candidate:	key, uint32_t hash);

  /
Candidate:	key)
  static inline int 
Candidate:	key* key);
};


// symbol
Candidate:	key);
};


// symboltable
Candidate:	key) needs to be stored.

Candidate:	key, object** s);

  // c
Candidate:	key(key* key, object** s)
Candidate:	key* key, object** s);
  
Candidate:	key, object** s);
  class
Candidate:	key;   // key based on ut
Candidate:	key based on utf8 string.
Candidate:	key;  // key based on str
Candidate:	key based on string*.

  
Candidate:	key, value, details).
// 
Candidate:	key == undefined the trip
Candidate:	key == null the triple ha
Candidate:	key contains the name of 
Candidate:	key is a number and (from
Candidate:	key && key < to).
  void 
Candidate:	key < to).
  void removen
Candidate:	key otherwise return -1.

Candidate:	key);

  // find entry fo
Candidate:	key otherwise return -1.

Candidate:	key, object* value);
  ob
Candidate:	key, object* value);

  o
Candidate:	key, object* value, prope
Candidate:	key, object* value, prope
Candidate:	key,
                    
Candidate:	keys to preallocated fixe
Candidate:	keysto(fixedarray* storag
Candidate:	keys to preallocated fixe
Candidate:	keysto(fixedarray* storag
Candidate:	keysto(fixedarray* storag
Candidate:	key that has been added t
Candidate:	key can only be called if
Candidate:	key();

  // accessors fo
Candidate:	key* key);

#ifdef debug

Candidate:	key);

#ifdef debug
  voi
Candidate:	key (slow).
  object* slo
Candidate:	key* key, object* value);
Candidate:	key, object* value);

  o
Candidate:	key* key, object* value, 
Candidate:	key, object* value, prope
Candidate:	key,
                obje
Candidate:	key, value) pair.
  inlin
Candidate:	key,
                    
Candidate:	key(uint32_t key);

  // 
Candidate:	key);

  // generate new 
Candidate:	keyindex = kprefixstartin
Candidate:	keyindex + 1;

  class nu
Candidate:	key;  // key containing u
Candidate:	key containing uint32_t.

Candidate:	key;  // key containing s
Candidate:	key containing string*.


Candidate:	keyed_load_ic,
    call_i
Candidate:	keyed_store_ic,

    // p
Candidate:	keyed_store_ic
  };

  en
Candidate:	keyed_load_stub() { retur
Candidate:	keyed_load_ic; }
  inline
Candidate:	keyed_store_stub() { retu
Candidate:	keyed_store_ic; }
  inlin
Candidate:	key]: for kind stub, the 
Candidate:	key.
  inline codestub::m
Candidate:	key();
  inline void set_
Candidate:	key(codestub::major major
Candidate:	keyoffset = kkindspecific
Candidate:	keys.
class jsarray: publ
Candidate:	api.h"
#include "ast.h"
#
Candidate:	api's extension mechanism
Candidate:	apicall to perform argume
Candidate:	aping labels.
  zonelist<
Candidate:	aping_labels(collector.la
Candidate:	aping_labels(collector.la
Candidate:	aping_labels(collector.la
Candidate:	aping_labels(catch_collec
Candidate:	token(token::value token)
Candidate:	token::value token);

  h
Candidate:	token);

  handle<script>
Candidate:	token, bool* ok);
  state
Candidate:	token_position,
         
Candidate:	token::value peek()) { re
Candidate:	token::value next()) { re
Candidate:	token::value token));
  v
Candidate:	token));
  void expect(to
Candidate:	token::value token, bool*
Candidate:	token, bool* ok);
  void 
Candidate:	token::eos, &ok);
  retur
Candidate:	token::eos, &ok);
    if 
Candidate:	token,
                  
Candidate:	token>

  // allocate a t
Candidate:	token) {
    statement* s
Candidate:	token::lbrace:
      retu
Candidate:	token::const:  // fall th
Candidate:	token::var:
      stmt = 
Candidate:	token::semicolon:
      n
Candidate:	token::if:
      stmt = p
Candidate:	token::do:
      stmt = p
Candidate:	token::while:
      stmt 
Candidate:	token::for:
      stmt = 
Candidate:	token::continue:
      st
Candidate:	token::break:
      stmt 
Candidate:	token::return:
      stmt
Candidate:	token::with:
      stmt =
Candidate:	token::switch:
      stmt
Candidate:	token::throw:
      stmt 
Candidate:	token::try: {
      // no
Candidate:	token::function:
      re
Candidate:	token::native:
      retu
Candidate:	token::debugger:
      st
Candidate:	token(token::native);
   
Candidate:	token::native);
    *ok =
Candidate:	token::native, check_ok);
Candidate:	token::function, check_ok
Candidate:	token::lparen, check_ok);
Candidate:	token::rparen);
  while (
Candidate:	token::rparen);
    if (!
Candidate:	token::comma, check_ok);

Candidate:	token::rparen, check_ok);
Candidate:	token::semicolon, check_o
Candidate:	token::init_var, var, lit
Candidate:	token::function, check_ok
Candidate:	token_position = scanner(
Candidate:	token::identifier) name =
Candidate:	token_position,
         
Candidate:	token::lbrace, check_ok);
Candidate:	token::rbrace) {
    stat
Candidate:	token::rbrace, check_ok);
Candidate:	token::var) {
    consume
Candidate:	token::var);
  } else if 
Candidate:	token::const) {
    consu
Candidate:	token::const);
    mode =
Candidate:	token::comma);
    handle
Candidate:	token::assign) {
      ex
Candidate:	token::assign, check_ok);
Candidate:	token::value op = (is_con
Candidate:	token::init_const : token
Candidate:	token::init_var);
      a
Candidate:	token::comma);

  if (!is
Candidate:	token::colon && expr &&
 
Candidate:	token::colon, check_ok);

Candidate:	token::if, check_ok);
  e
Candidate:	token::lparen, check_ok);
Candidate:	token::rparen, check_ok);
Candidate:	token::else) {
    next()
Candidate:	token::continue, check_ok
Candidate:	token::value tok = peek()
Candidate:	token::semicolon && tok !
Candidate:	token::rbrace) {
    labe
Candidate:	token::break, check_ok);

Candidate:	token::value tok = peek()
Candidate:	token::semicolon && tok !
Candidate:	token::rbrace) {
    labe
Candidate:	token. it is necessary to
Candidate:	token::return, check_ok);
Candidate:	token::value tok = peek()
Candidate:	token::semicolon ||
     
Candidate:	token::rbrace ||
      to
Candidate:	token::eos) {
    expects
Candidate:	token::with, check_ok);
 
Candidate:	token::lparen, check_ok);
Candidate:	token::rparen, check_ok);
Candidate:	token::case) {
    expect
Candidate:	token::case, check_ok);
 
Candidate:	token::default, check_ok)
Candidate:	token::colon, check_ok);

Candidate:	token::case &&
         p
Candidate:	token::default &&
       
Candidate:	token::rbrace) {
    stat
Candidate:	token::switch, check_ok);
Candidate:	token::lparen, check_ok);
Candidate:	token::rparen, check_ok);
Candidate:	token::lbrace, check_ok);
Candidate:	token::rbrace) {
    case
Candidate:	token::rbrace, check_ok);
Candidate:	token::throw, check_ok);

Candidate:	token::try, check_ok);

 
Candidate:	token::value tok = peek()
Candidate:	token::catch && tok != to
Candidate:	token::finally) {
    rep
Candidate:	token::catch) {
    has_c
Candidate:	token::catch);

    expec
Candidate:	token::lparen, check_ok);
Candidate:	token::rparen, check_ok);
Candidate:	token::lbrace) {
      //
Candidate:	token::lbrace, check_ok);
Candidate:	token::finally || !has_ca
Candidate:	token::finally);
    // d
Candidate:	token::do, check_ok);
  s
Candidate:	token::while, check_ok);

Candidate:	token::lparen, check_ok);
Candidate:	token::rparen, check_ok);
Candidate:	token::semicolon) consume
Candidate:	token::semicolon);

  if 
Candidate:	token::while, check_ok);

Candidate:	token::lparen, check_ok);
Candidate:	token::rparen, check_ok);
Candidate:	token::for, check_ok);
  
Candidate:	token::lparen, check_ok);
Candidate:	token::semicolon) {
    i
Candidate:	token::var || peek() == t
Candidate:	token::const) {
      exp
Candidate:	token::in && each != null
Candidate:	token::in, check_ok);
   
Candidate:	token::rparen, check_ok);
Candidate:	token::in) {
        // r
Candidate:	token::in, check_ok);
   
Candidate:	token::rparen, check_ok);
Candidate:	token::semicolon, check_o
Candidate:	token::semicolon) {
    c
Candidate:	token::semicolon, check_o
Candidate:	token::rparen) {
    expr
Candidate:	token::rparen, check_ok);
Candidate:	token::comma) {
    expec
Candidate:	token::comma, check_ok);

Candidate:	token::comma, result, rig
Candidate:	token::isassignmentop(pee
Candidate:	token::value op = next();
Candidate:	token::assign &&
      pr
Candidate:	token::conditional) retur
Candidate:	token::conditional);
  //
Candidate:	token::colon, check_ok);

Candidate:	token::value tok, bool ac
Candidate:	token::in && !accept_in)

Candidate:	token::precedence(tok);
}
Candidate:	token::value op = next();
Candidate:	token::add:
            x
Candidate:	token::sub:
            x
Candidate:	token::mul:
            x
Candidate:	token::div:
            x
Candidate:	token::bit_or:
          
Candidate:	token::bit_and:
         
Candidate:	token::bit_xor:
         
Candidate:	token::shl: {
           
Candidate:	token::shr: {
           
Candidate:	token::sar: {
           
Candidate:	token::iscompareop(op)) {
Candidate:	token::value cmp = op;
  
Candidate:	token::ne: cmp = token::e
Candidate:	token::eq; break;
       
Candidate:	token::ne_strict: cmp = t
Candidate:	token::eq_strict; break;

Candidate:	token::not, x));
        
Candidate:	token::value op = peek();
Candidate:	token::isunaryop(op)) {
 
Candidate:	token::add:
          ret
Candidate:	token::sub:
          ret
Candidate:	token::bit_not:
         
Candidate:	token::iscountop(op)) {
 
Candidate:	token::iscountop(peek()))
Candidate:	token::value next = next(
Candidate:	token::new) {
    result 
Candidate:	token::lbrack: {
        
Candidate:	token::lbrack);
        i
Candidate:	token::rbrack, check_ok);
Candidate:	token::lparen: {
        
Candidate:	token::period: {
        
Candidate:	token::period);
        i
Candidate:	token::new) {
    consume
Candidate:	token::new);
    new_posi
Candidate:	token::function) {
    ex
Candidate:	token::function, check_ok
Candidate:	token_position = scanner(
Candidate:	token::identifier) name =
Candidate:	token_position,
         
Candidate:	token::lbrack: {
        
Candidate:	token::lbrack);
        i
Candidate:	token::rbrack, check_ok);
Candidate:	token::period: {
        
Candidate:	token::period);
        i
Candidate:	token::lparen: {
        
Candidate:	token::debugger, check_ok
Candidate:	token(token::value token)
Candidate:	token::value token) {
  /
Candidate:	token) {
  // we don't re
Candidate:	token == token::illegal &
Candidate:	token::illegal && scanner
Candidate:	tokens are treated specia
Candidate:	token) {
  case token::eo
Candidate:	token::eos:
    return re
Candidate:	token::number:
    return
Candidate:	token_number",
          
Candidate:	token::string:
    return
Candidate:	token_string",
          
Candidate:	token::identifier:
    re
Candidate:	token_identifier",
      
Candidate:	token::string(token);
   
Candidate:	token);
    assert(name !
Candidate:	token", vector<const char
Candidate:	token::this: {
      cons
Candidate:	token::this);
      if (i
Candidate:	token::null_literal:
    
Candidate:	token::null_literal);
   
Candidate:	token::true_literal:
    
Candidate:	token::true_literal);
   
Candidate:	token::false_literal:
   
Candidate:	token::false_literal);
  
Candidate:	token::identifier: {
    
Candidate:	token::number: {
      co
Candidate:	token::number);
      dou
Candidate:	token::string: {
      co
Candidate:	token::string);
      han
Candidate:	token::assign_div:
      
Candidate:	token::div:
      result 
Candidate:	token::lbrack:
      resu
Candidate:	token::lbrace:
      resu
Candidate:	token::lparen:
      cons
Candidate:	token::lparen);
      res
Candidate:	token::rparen, check_ok);
Candidate:	token::mod:
      if (all
Candidate:	token::value tok = peek()
Candidate:	token::peek returns the v
Candidate:	token but
      // locati
Candidate:	token.
      // therefore
Candidate:	token
      next();
     
Candidate:	token(tok);
      *ok = f
Candidate:	token::lbrack, check_ok);
Candidate:	token::rbrack) {
    expr
Candidate:	token::comma) {
      ele
Candidate:	token::rbrack) {
      ex
Candidate:	token::comma, check_ok);

Candidate:	token::rbrack, check_ok);
Candidate:	token::lbrace, check_ok);
Candidate:	token::rbrace) {
    lite
Candidate:	token::identifier: {
    
Candidate:	token::identifier) {
    
Candidate:	token::rbrace) expect(tok
Candidate:	token::comma, check_ok);

Candidate:	token::string: {
        
Candidate:	token::string);
        h
Candidate:	token::number: {
        
Candidate:	token::number);
        d
Candidate:	token::rbrace, check_ok);
Candidate:	token::colon, check_ok);

Candidate:	token::rbrace) expect(tok
Candidate:	token::comma, check_ok);

Candidate:	token::rbrace, check_ok);
Candidate:	token::lparen, check_ok);
Candidate:	token::rparen);
  while (
Candidate:	token::rparen);
    if (!
Candidate:	token::comma, check_ok);

Candidate:	token::rparen, check_ok);
Candidate:	token_position,
         
Candidate:	token::lparen, check_ok);
Candidate:	token::rparen);
    while
Candidate:	token::rparen);
      if 
Candidate:	token::comma, check_ok);

Candidate:	token::rparen, check_ok);
Candidate:	token::lbrace, check_ok);
Candidate:	token::init_var, fproxy,

Candidate:	token::rbrace, check_ok);
Candidate:	token::rbrace, check_ok);
Candidate:	token_position(function_t
Candidate:	token_position);
    }
  
Candidate:	token::mod, check_ok);
  
Candidate:	token::value token) {
  t
Candidate:	token) {
  token::value n
Candidate:	token::value next = next(
Candidate:	token);
  assert(next == 
Candidate:	token);
}


void parser::
Candidate:	token::value token, bool*
Candidate:	token, bool* ok) {
  toke
Candidate:	token::value next = next(
Candidate:	token) return;
  reportun
Candidate:	token(next);
  *ok = fals
Candidate:	token::value tok = peek()
Candidate:	token::semicolon) {
    n
Candidate:	token::rbrace ||
      to
Candidate:	token::eos) {
    return;
Candidate:	token::semicolon, ok);
}

Candidate:	token::identifier, ok);
 
Candidate:	token::identifier, ok);
 
Candidate:	token = scanner_.literal_
Candidate:	token, "get") == 0;
    *
Candidate:	token, "set") == 0;
  }
 
Candidate:	key, int pos) {
    if (o
Candidate:	key, int pos) {
    retur
Candidate:	key, pos);
  }

  virtual
Candidate:	key = new(literal(id));
 
Candidate:	key, value));
  propertie
Candidate:	key we
            // cho
Candidate:	key we
      // choose to
Candidate:	keyword; see ecma-262,
  
Candidate:	key we
        // choose 
Candidate:	key we
        // choose 
Candidate:	key = property->key()->as
Candidate:	key()->asliteral();
     
Candidate:	key != null &&
          
Candidate:	key->handle().is_identica
Candidate:	keyword
  // 'new' can ei
Candidate:	keywords greedily and kee
Candidate:	keyword. in some browser

Candidate:	key = null;
    switch (p
Candidate:	keys as literal symbols t
Candidate:	key = new(literal(id));
 
Candidate:	key = newnumberliteral(in
Candidate:	key = new(literal(string)
Candidate:	key = newnumberliteral(va
Candidate:	key, value));
    if ((pr
Candidate:	key = property->key()->ha
Candidate:	key()->handle();
      li
Candidate:	key);
      constant_prop
Candidate:	keyword or name.
//
funct
Candidate:	key thread::createthreadl
Candidate:	key() {
  pthread_key_t k
Candidate:	key_t key;
  int result =
Candidate:	key;
  int result = pthre
Candidate:	key_create(&key, null);
 
Candidate:	key, null);
  use(result)
Candidate:	key>(key);
}


void threa
Candidate:	key);
}


void thread::de
Candidate:	key(localstoragekey key) 
Candidate:	key key) {
  pthread_key_
Candidate:	key) {
  pthread_key_t pt
Candidate:	key_t pthread_key = stati
Candidate:	key = static_cast<pthread
Candidate:	key_t>(key);
  int result
Candidate:	key);
  int result = pthr
Candidate:	key_delete(pthread_key);

Candidate:	key);
  use(result);
  as
Candidate:	key key) {
  pthread_key_
Candidate:	key) {
  pthread_key_t pt
Candidate:	key_t pthread_key = stati
Candidate:	key = static_cast<pthread
Candidate:	key_t>(key);
  return pth
Candidate:	key);
  return pthread_ge
Candidate:	key);
}


void thread::se
Candidate:	key key, void* value) {
 
Candidate:	key, void* value) {
  pth
Candidate:	key_t pthread_key = stati
Candidate:	key = static_cast<pthread
Candidate:	key_t>(key);
  pthread_se
Candidate:	key);
  pthread_setspecif
Candidate:	key, value);
}


void thr
Candidate:	key thread::createthreadl
Candidate:	key() {
  pthread_key_t k
Candidate:	key_t key;
  int result =
Candidate:	key;
  int result = pthre
Candidate:	key_create(&key, null);
 
Candidate:	key, null);
  use(result)
Candidate:	key>(key);
}


void threa
Candidate:	key);
}


void thread::de
Candidate:	key(localstoragekey key) 
Candidate:	key key) {
  pthread_key_
Candidate:	key) {
  pthread_key_t pt
Candidate:	key_t pthread_key = stati
Candidate:	key = static_cast<pthread
Candidate:	key_t>(key);
  int result
Candidate:	key);
  int result = pthr
Candidate:	key_delete(pthread_key);

Candidate:	key);
  use(result);
  as
Candidate:	key key) {
  pthread_key_
Candidate:	key) {
  pthread_key_t pt
Candidate:	key_t pthread_key = stati
Candidate:	key = static_cast<pthread
Candidate:	key_t>(key);
  return pth
Candidate:	key);
  return pthread_ge
Candidate:	key);
}


void thread::se
Candidate:	key key, void* value) {
 
Candidate:	key, void* value) {
  pth
Candidate:	key_t pthread_key = stati
Candidate:	key = static_cast<pthread
Candidate:	key_t>(key);
  pthread_se
Candidate:	key);
  pthread_setspecif
Candidate:	key, value);
}


void thr
Candidate:	key thread::createthreadl
Candidate:	key() {
  unimplemented()
Candidate:	key>(0);
}


void thread:
Candidate:	key(localstoragekey key) 
Candidate:	key key) {
  unimplemente
Candidate:	key) {
  unimplemented();
Candidate:	key key) {
  unimplemente
Candidate:	key) {
  unimplemented();
Candidate:	key key, void* value) {
 
Candidate:	key, void* value) {
  uni
Candidate:	api
  if (isbadwriteptr(p
Candidate:	key thread::createthreadl
Candidate:	key() {
  dword result = 
Candidate:	key>(result);
}


void th
Candidate:	key(localstoragekey key) 
Candidate:	key key) {
  bool result 
Candidate:	key) {
  bool result = tl
Candidate:	key));
  use(result);
  a
Candidate:	key key) {
  return tlsge
Candidate:	key) {
  return tlsgetval
Candidate:	key));
}


void thread::s
Candidate:	key key, void* value) {
 
Candidate:	key, void* value) {
  boo
Candidate:	key), value);
  use(resul
Candidate:	keys.
  enum localstorage
Candidate:	key {};

  // create new 
Candidate:	key createthreadlocalkey(
Candidate:	key();
  static void dele
Candidate:	key(localstoragekey key);
Candidate:	key key);
  static void* 
Candidate:	key);
  static void* gett
Candidate:	key key);
  static void s
Candidate:	key);
  static void setth
Candidate:	key key, void* value);

 
Candidate:	key, void* value);

  // 
Candidate:	token::string(node->op())
Candidate:	token::string(node->op())
Candidate:	token::string(node->op())
Candidate:	token::string(node->op())
Candidate:	token::string(node->op())
Candidate:	token::string(node->op())
Candidate:	token::name(node->op()));
Candidate:	token::name(node->op()), 
Candidate:	token::name(node->op()));
Candidate:	token::name(node->op()));
Candidate:	token::name(node->op()));
Candidate:	key());
    print(": ");

Candidate:	key = node->key();
  lite
Candidate:	key();
  literal* literal
Candidate:	key->asliteral();
  if (l
Candidate:	key);
    print("]");
  }
Candidate:	key", node->properties()-
Candidate:	key());
    printindented
Candidate:	key()->asliteral();
  if 
Candidate:	key", node->key());
  }
}
Candidate:	key());
  }
}


void astp
Candidate:	key_->issymbol());
  desc
Candidate:	key()->shortprint();
  pr
Candidate:	key, property attributes,
Candidate:	key() { return key_; }

 
Candidate:	key_; }

  object* keytos
Candidate:	keytosymbol() {
    if (!
Candidate:	key_->issymbol()) {
     
Candidate:	key_);
      if (result->
Candidate:	key_ = string::cast(resul
Candidate:	key_;
  }

  string* getk
Candidate:	key() { return key_; }
  
Candidate:	key_; }
  object* getvalu
Candidate:	key_;
  object* value_;
 
Candidate:	key, object* value, prope
Candidate:	key_ = key;
    value_ = 
Candidate:	key;
    value_ = value;

Candidate:	key, object* value, prope
Candidate:	key_(key),
        value_
Candidate:	key),
        value_(valu
Candidate:	key,
             object*
Candidate:	key_(key),
        value_
Candidate:	key),
        value_(valu
Candidate:	key, map* map, propertyat
Candidate:	key, map, attributes, map
Candidate:	key)
      : descriptor(k
Candidate:	key, smi::fromint(0), non
Candidate:	key,
                  in
Candidate:	key, smi::fromint(field_i
Candidate:	key,
                    
Candidate:	key, function, attributes
Candidate:	key,
                    
Candidate:	key, proxy, attributes, c
Candidate:	key() { return descriptor
Candidate:	key(pos_); }
  object* ge
Candidate:	key()); }

  void get(des
Candidate:	key, this method returns 
Candidate:	key treat a missing patte
Candidate:	key behavior: return the 
Candidate:	key and kjs have length e
Candidate:	key.
%functionsetlength($
Candidate:	key, the value it is set 
Candidate:	key
// the value of the e
Candidate:	key, the value it is set 
Candidate:	key
// the value of the e
Candidate:	token::assign, result_, v
Candidate:	api.h"
#include "argument
Candidate:	apifunction(arguments arg
Candidate:	apifunction(data);
}


st
Candidate:	api objects to call the a
Candidate:	api function for adding
 
Candidate:	api<v8::function>(raw_fun
Candidate:	api<v8::value>(args.at<ob
Candidate:	api object to call the ap
Candidate:	api function for
  // rem
Candidate:	api<v8::function>(raw_fun
Candidate:	apiterator iterator;
    
Candidate:	apiterator iterator;
  wh
Candidate:	apiterator iterator;
  wh
Candidate:	apiterator iterator;
  wh
Candidate:	apiterator iterator;
  wh
Candidate:	token_position();
       
Candidate:	key(constant_properties->
Candidate:	key->issymbol()) {
      
Candidate:	key is a symbol it is not
Candidate:	key));
        assert(!na
Candidate:	key, &element_index)) {
 
Candidate:	key->isnumber());
       
Candidate:	key->number();
        ch
Candidate:	key nor kjs creates the
 
Candidate:	key) {
  handlescope scop
Candidate:	key, object };
    handle
Candidate:	key is an array index.
  
Candidate:	key, &index)) {
    retur
Candidate:	key to a string - possibl
Candidate:	key->isstring()) {
    na
Candidate:	key);
  } else {
    bool
Candidate:	key, &has_pending_excepti
Candidate:	key = args.at<object>(1);
Candidate:	key);
}


object* runtime
Candidate:	key,
                    
Candidate:	key, object };
    handle
Candidate:	key is an array index.
  
Candidate:	key, &index)) {
    asser
Candidate:	key, safari and opera you
Candidate:	key->isstring()) {
    ha
Candidate:	key)->asarrayindex(&index
Candidate:	key_string = handle<strin
Candidate:	key);
      key_string->t
Candidate:	key_string->tryflatten();
Candidate:	key_string, value, attr);
Candidate:	key to a string.
  bool h
Candidate:	key, &has_pending_excepti
Candidate:	key = args.at<object>(1);
Candidate:	key, value, attributes);

Candidate:	key, args[1]);
  return o
Candidate:	key);
}


static object* 
Candidate:	key, args[1]);

  // only
Candidate:	key)) return heap::true_v
Candidate:	key->asarrayindex(&index)
Candidate:	key, args[1]);
    if (ob
Candidate:	key)) return heap::true_v
Candidate:	key, args[1]);

  uint32_
Candidate:	key->asarrayindex(&index)
Candidate:	key, &result);
  if (!res
Candidate:	keysfor(object);
}


// r
Candidate:	keysinfixedarrayfor(objec
Candidate:	key to an index. if succe
Candidate:	key to a string.
  handle
Candidate:	key = handle<string>::cas
Candidate:	key into an array index.

Candidate:	key->asarrayindex(&index)
Candidate:	key->equals(heap::length_
Candidate:	key->equals(heap::callee_
Candidate:	key);
}


static object* 
Candidate:	keys or intervals.  keys 
Candidate:	keys can have
// gaps in 
Candidate:	keys.
static object* runt
Candidate:	keys(arguments args) {
  
Candidate:	keys into it, then remove
Candidate:	keys that are not integer
Candidate:	keys = getkeysinfixedarra
Candidate:	keysinfixedarrayfor(array
Candidate:	keys_length = keys->lengt
Candidate:	keys->length();
    for (
Candidate:	keys_length; i++) {
     
Candidate:	key = keys->get(i);
     
Candidate:	keys->get(i);
      uint3
Candidate:	key, &index) || index >= 
Candidate:	keys.
        keys->set_u
Candidate:	keys->set_undefined(i);
 
Candidate:	keys);
  } else {
    han
Candidate:	keys(*names, static_cast<
Candidate:	keysfornamedinterceptor(o
Candidate:	keysforindexedinterceptor
Candidate:	keys = getkeysinfixedarra
Candidate:	keysinfixedarrayfor(ext);
Candidate:	keys->length(); i++) {
  
Candidate:	keys->get(i)->isstring())
Candidate:	key(string::cast(keys->ge
Candidate:	keys->get(i)));
      set
Candidate:	key, getproperty(ext, key
Candidate:	key), none);
    }
  }

 
Candidate:	apifunction, 1) \
  f(ist
Candidate:	keys, 2) \
  f(movearrayc
Candidate:	key, safari and opera.
  
Candidate:	key,
                    
Candidate:	key);

  // helper functi
Candidate:	key) {
  return %deletepr
Candidate:	key));
};


// ecma-262, 
Candidate:	keys for the given object
Candidate:	keys() {
  return %getpro
Candidate:	key against an object by 
Candidate:	key; return the key as a 
Candidate:	key as a string if
// it 
Candidate:	key(key) {
  var string =
Candidate:	key) {
  var string = %to
Candidate:	key);
  if (%hasproperty(
Candidate:	token::initialize();
}



Candidate:	token.
  skipwhitespace(t
Candidate:	token::value scanner::nex
Candidate:	tokens.
  stacklimitcheck
Candidate:	token = token::illegal;
 
Candidate:	token::illegal;
  } else 
Candidate:	token;
}


void scanner::
Candidate:	token::value scanner::ski
Candidate:	token::comment;
}


token
Candidate:	token::value scanner::ski
Candidate:	token::comment;
    }
  }
Candidate:	token::illegal;
}


token
Candidate:	token::value scanner::sca
Candidate:	token::lt;
}


void scann
Candidate:	token::value token;
  boo
Candidate:	token;
  bool has_line_te
Candidate:	token
    next_.location.
Candidate:	token = scantoken();
  } 
Candidate:	token();
  } while (token
Candidate:	token == token::comment);
Candidate:	token::comment);

  next_
Candidate:	token = token;
}


void s
Candidate:	token;
}


void scanner::
Candidate:	token::value scanner::sca
Candidate:	token::illegal;
      sca
Candidate:	token::illegal;
  }
  ter
Candidate:	token::string;
}


token:
Candidate:	token::value scanner::sel
Candidate:	token::value tok) {
  adv
Candidate:	token::value scanner::sel
Candidate:	token::value then, token:
Candidate:	token::value else_) {
  a
Candidate:	token::value scanner::sca
Candidate:	token() {
  switch (c0_) 
Candidate:	token::lte);
      if (c0
Candidate:	token::assign_shl, token:
Candidate:	token::shl);
      if (c0
Candidate:	token::lt;

    case '>':
Candidate:	token::gte);
      if (c0
Candidate:	token::assign_sar);
     
Candidate:	token::assign_shr, token:
Candidate:	token::shr);
        retu
Candidate:	token::sar;
      }
     
Candidate:	token::gt;

    case '=':
Candidate:	token::eq_strict, token::
Candidate:	token::eq);
      return 
Candidate:	token::assign;

    case 
Candidate:	token::ne_strict, token::
Candidate:	token::ne);
      return 
Candidate:	token::not;

    case '+'
Candidate:	token::inc);
      if (c0
Candidate:	token::assign_add);
     
Candidate:	token::add;

    case '-'
Candidate:	token::dec);
      if (c0
Candidate:	token::assign_sub);
     
Candidate:	token::sub;

    case '*'
Candidate:	token::assign_mul, token:
Candidate:	token::mul);

    case '%
Candidate:	token::assign_mod, token:
Candidate:	token::mod);

    case '/
Candidate:	token::assign_div);
     
Candidate:	token::div;

    case '&'
Candidate:	token::and);
      if (c0
Candidate:	token::assign_bit_and);
 
Candidate:	token::bit_and;

    case
Candidate:	token::or);
      if (c0_
Candidate:	token::assign_bit_or);
  
Candidate:	token::bit_or;

    case 
Candidate:	token::assign_bit_xor, to
Candidate:	token::bit_xor);

    cas
Candidate:	token::period;

    case 
Candidate:	token::colon);

    case 
Candidate:	token::semicolon);

    c
Candidate:	token::comma);

    case 
Candidate:	token::lparen);

    case
Candidate:	token::rparen);

    case
Candidate:	token::lbrack);

    case
Candidate:	token::rbrack);

    case
Candidate:	token::lbrace);

    case
Candidate:	token::rbrace);

    case
Candidate:	token::conditional);

   
Candidate:	token::bit_not);

    def
Candidate:	token::eos;
      return 
Candidate:	token::illegal);
  }

  u
Candidate:	token::illegal;
}


// re
Candidate:	token::value scanner::sca
Candidate:	token::illegal;
        w
Candidate:	token::illegal;  // no ex
Candidate:	token::illegal;
    scand
Candidate:	token::illegal;

  return
Candidate:	token::number;
}


uc32 s
Candidate:	token::value scanner::sca
Candidate:	token::illegal;
    addch
Candidate:	token::illegal;
      add
Candidate:	token::identifier;

  // 
Candidate:	token::identifier;

  ret
Candidate:	token::lookup(&literals_.
Candidate:	token is either '/' or '/
Candidate:	key handles it.
  if (!pu
Candidate:	key handles it.
    if (c
Candidate:	key and kjs.
    if (ch =
Candidate:	keywords (this is probabl
Candidate:	keyword.
  if (has_escape
Candidate:	token.h"
#include "char-p
Candidate:	token.
  token::value nex
Candidate:	token::value next();

  /
Candidate:	token look-ahead (past th
Candidate:	token returned by next())
Candidate:	token::value peek() const
Candidate:	token; }

  // returns tr
Candidate:	token.
  bool has_line_te
Candidate:	token
  // (the token ret
Candidate:	token returned by next())
Candidate:	token (the
  // token ret
Candidate:	token returned by next())
Candidate:	token (the token that
  /
Candidate:	token that
  // would be 
Candidate:	token (that would be retu
Candidate:	tokens, which is what it 
Candidate:	token.
  struct tokendesc
Candidate:	tokendesc {
    token::va
Candidate:	token::value token;
    l
Candidate:	token;
    location locat
Candidate:	tokendesc current_;  // d
Candidate:	token (as returned by nex
Candidate:	tokendesc next_;     // d
Candidate:	token (one token look-ahe
Candidate:	token look-ahead)
  bool 
Candidate:	token::value skipsingleli
Candidate:	token::value skipmultilin
Candidate:	token::value select(token
Candidate:	token::value tok);
  inli
Candidate:	token::value select(uc32 
Candidate:	token::value then, token:
Candidate:	token::value else_);

  v
Candidate:	token::value scantoken();
Candidate:	token();
  void scandecim
Candidate:	token::value scannumber(b
Candidate:	token::value scanidentifi
Candidate:	token::value scanstring()
Candidate:	token::value scanhtmlcomm
Candidate:	key values in the hash ma
Candidate:	key1, void* key2) {
  str
Candidate:	key2) {
  string* name1 =
Candidate:	key1);
  string* name2 = 
Candidate:	key2);
  assert(name1->is
Candidate:	key == name.location());

Candidate:	key) == *name);
    asser
Candidate:	api.h"
#include "executio
Candidate:	keyreference(stubcache::k
Candidate:	key");
  add(sctablerefer
Candidate:	keyreference(stubcache::k
Candidate:	key");
  add(sctablerefer
Candidate:	key) const {
  int index 
Candidate:	key);
  return index >=0 
Candidate:	key) const {
  int index 
Candidate:	key);
  return index >=0 
Candidate:	key) const {
  if (key ==
Candidate:	key == null) return -1;
 
Candidate:	key, hash(key), false);
 
Candidate:	key), false);
  return en
Candidate:	key, int index) {
  hashm
Candidate:	key, hash(key), true);
  
Candidate:	key), true);
  entry->val
Candidate:	key) {
  return reinterpr
Candidate:	key) >> 2;
}


static boo
Candidate:	key1, void* key2) {
  ret
Candidate:	key2) {
  return key1 == 
Candidate:	key1 == key2;
}


seriali
Candidate:	key2;
}


serializer::ser
Candidate:	key) const;

  const char
Candidate:	key) const;

 private:
  
Candidate:	key) {
    return reinter
Candidate:	key) >> 2;
  }

  int ind
Candidate:	key) const;

  static boo
Candidate:	key1, void* key2) { retur
Candidate:	key2) { return key1 == ke
Candidate:	key1 == key2; }

  void p
Candidate:	key2; }

  void put(addre
Candidate:	key, int index);
};


cla
Candidate:	key) const {
    if (key 
Candidate:	key == 0) return null;
  
Candidate:	key);
  }

 private:
  ad
Candidate:	key) const {
    int type
Candidate:	key >> kreferencetypeshif
Candidate:	key & kreferenceidmask;
 
Candidate:	key, address value) {
   
Candidate:	key) = value;
  }
};


//
Candidate:	api.h"
#include "serializ
Candidate:	keyed_load_ic);
      cas
Candidate:	keyed_store_ic);
      ca
Candidate:	token = null;


char* hea
Candidate:	token = null;
  if (debug
Candidate:	tokenifchanged(object* f)
Candidate:	token = jsglobalobject::c
Candidate:	token();
      if (token 
Candidate:	token != current_security
Candidate:	token) {
        add("sec
Candidate:	token);
        current_s
Candidate:	token = token;
      }
  
Candidate:	token;
      }
    } else
Candidate:	key = r.getkey();
       
Candidate:	key();
        if (key->i
Candidate:	key->isstring() || key->i
Candidate:	key->isnumber()) {
      
Candidate:	key->isstring()) {
      
Candidate:	key)->length();
         
Candidate:	key->isstring()) {
      
Candidate:	key));
          } else {
Candidate:	key->shortprint();
      
Candidate:	key         =============
Candidate:	key = jsobject::cast(p)->
Candidate:	key != heap::undefined_va
Candidate:	key->isstring() ||
      
Candidate:	key))) {
          print_
Candidate:	key;
      }
    } else {
Candidate:	tokenifchanged(object* fu
Candidate:	key.
              ++posi
Candidate:	key and kjs behavior when
Candidate:	key
  // and kjs have thi
Candidate:	key and kjs.
  if (%_argu
Candidate:	token check if needed.
  
Candidate:	token check if needed.
  
Candidate:	token check if needed.
  
Candidate:	key_offset(sctablereferen
Candidate:	keyreference(table));
  e
Candidate:	key in the entry matches 
Candidate:	key_offset));
  __ ldr(ip
Candidate:	keyed loads have not been
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyedstorestubcompiler::c
	KEY FOUND:	keyedstorestubcompiler::c
Candidate:	token check if needed.
  
Candidate:	token check if needed.
  
Candidate:	token check if needed.
  
Candidate:	key_offset(sctablereferen
Candidate:	keyreference(table));
  e
Candidate:	key in the entry matches 
Candidate:	key_offset));
  __ j(not_
Candidate:	keyed_load_ic);
  code* c
Candidate:	keyedloadic_miss);
  }

 
Candidate:	keyedstorestubcompiler::c
	KEY FOUND:	keyedstorestubcompiler::c
Candidate:	key
  //  -- esp[8] : rec
Candidate:	keyed_store_field, 1);

 
Candidate:	keyed_store_field, 1);
  
Candidate:	keyedstoreic_miss));
  __
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyed_load_field, 1);

  
Candidate:	keyed_load_field, 1);
  g
Candidate:	keyed_load_ic);

  // ret
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyed_load_callback, 1);

Candidate:	keyed_load_callback, 1);

Candidate:	keyed_load_ic);

  // ret
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyed_load_constant_funct
Candidate:	keyed_load_constant_funct
Candidate:	keyed_load_ic);

  // ret
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyed_load_interceptor, 1
Candidate:	keyed_load_interceptor, 1
Candidate:	keyed_load_ic);

  // ret
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyed_load_array_length, 
Candidate:	keyed_load_array_length, 
Candidate:	keyed_load_ic);

  // ret
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyed_load_string_length,
Candidate:	keyed_load_string_length,
Candidate:	keyed_load_ic);

  // ret
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyed_load_string_length,
Candidate:	keyed_load_string_length,
Candidate:	keyed_load_ic);

  // ret
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyed_load_string_length,
Candidate:	keyed_load_string_length,
Candidate:	keyed_load_ic);

  // ret
Candidate:	keyedloadstubcompiler::co
	KEY FOUND:	keyedloadstubcompiler::co
Candidate:	keyed_load_function_proto
Candidate:	keyed_load_function_proto
Candidate:	keyed_load_ic);

  // ret
Candidate:	api.h"
#include "argument
Candidate:	apinamedpropertyaccess("l
Candidate:	apinamedpropertyaccess("s
Candidate:	key, primary_flags, prima
Candidate:	key = name;
  primary->va
Candidate:	keyedloadfield(string* na
Candidate:	keyed_load_ic, field);
  
Candidate:	keyedloadstubcompiler com
Candidate:	keyedloadic", code::cast(
Candidate:	keyedloadconstant(string*
Candidate:	keyed_load_ic, constant_f
Candidate:	keyedloadstubcompiler com
Candidate:	keyedloadic", code::cast(
Candidate:	keyedloadinterceptor(stri
Candidate:	keyed_load_ic, intercepto
Candidate:	keyedloadstubcompiler com
Candidate:	keyedloadic", code::cast(
Candidate:	keyedloadcallback(string*
Candidate:	keyed_load_ic, callbacks)
Candidate:	keyedloadstubcompiler com
Candidate:	keyedloadic", code::cast(
Candidate:	keyedloadarraylength(stri
Candidate:	keyed_load_ic, callbacks)
Candidate:	keyedloadstubcompiler com
Candidate:	keyedloadic", code::cast(
Candidate:	keyedloadshortstringlengt
Candidate:	keyed_load_ic, callbacks)
Candidate:	keyedloadstubcompiler com
Candidate:	keyedloadic", code::cast(
Candidate:	keyedloadmediumstringleng
Candidate:	keyed_load_ic, callbacks)
Candidate:	keyedloadstubcompiler com
Candidate:	keyedloadic", code::cast(
Candidate:	keyedloadlongstringlength
Candidate:	keyed_load_ic, callbacks)
Candidate:	keyedloadstubcompiler com
Candidate:	keyedloadic", code::cast(
Candidate:	keyedloadfunctionprototyp
Candidate:	keyed_load_ic, callbacks)
Candidate:	keyedloadstubcompiler com
Candidate:	keyedloadic", code::cast(
Candidate:	keyedstorefield(string* n
Candidate:	keyed_store_ic, type);
  
Candidate:	keyedstorestubcompiler co
Candidate:	keyedstoreic", code::cast
Candidate:	key = heap::empty_string(
Candidate:	key = heap::empty_string(
Candidate:	keyed and non-keyed loads
Candidate:	keyed loads may end up he
Candidate:	keyedloadic constructors.
Candidate:	keyed_load_stub());
  if 
Candidate:	keyedloadstubcompiler::ge
	KEY FOUND:	keyedloadstubcompiler::ge
Candidate:	keyed_load_ic,
          
Candidate:	keyedstorestubcompiler::g
	KEY FOUND:	keyedstorestubcompiler::g
Candidate:	keyed_store_ic,
         
Candidate:	key;
    code* value;
  }
Candidate:	keyedloadfield(string* na
Candidate:	keyedloadcallback(string*
Candidate:	keyedloadconstant(string*
Candidate:	keyedloadinterceptor(stri
Candidate:	keyedloadarraylength(stri
Candidate:	keyedloadshortstringlengt
Candidate:	keyedloadmediumstringleng
Candidate:	keyedloadlongstringlength
Candidate:	keyedloadfunctionprototyp
Candidate:	keyedstorefield(string* n
Candidate:	key = (reinterpret_cast<u
Candidate:	key & ((kprimarytablesize
Candidate:	key = seed - reinterpret_
Candidate:	key & ((ksecondarytablesi
Candidate:	keyreference(stubcache::t
Candidate:	key));
  }


  static sct
Candidate:	keyedloadstubcompiler: pu
Candidate:	keyedstorestubcompiler: p
Candidate:	api. it does not
appear o
Candidate:	keyword does not work. */
Candidate:	apital b in a class (in b
Candidate:	api for this
function had
Candidate:	api should change to eith
Candidate:	api. this includes some
f
Candidate:	api. the data for these t
Candidate:	api and so not exported f
Candidate:	token.h"

namespace v8 { 
Candidate:	token::name_[num_tokens] 
Candidate:	tokens] = {
  token_list(
Candidate:	token_list(t, t, ignore_t
Candidate:	token)
};
#undef t
#endif
Candidate:	token::string_[num_tokens
Candidate:	tokens] = {
  token_list(
Candidate:	token_list(t, t, ignore_t
Candidate:	token)
};
#undef t


#def
Candidate:	token::precedence_[num_to
Candidate:	tokens] = {
  token_list(
Candidate:	token_list(t, t, ignore_t
Candidate:	token)
};
#undef t


// a
Candidate:	token values.

// larger 
Candidate:	tokens
static uint8_t has
Candidate:	token::value token::looku
Candidate:	token::lookup(const char*
Candidate:	token::initialize() {
  i
Candidate:	token_list(ignore_token, 
Candidate:	token, t, ignore_token)
 
Candidate:	token)
    illegal
  };
#
Candidate:	tokens <= 256);  // hasht
Candidate:	token_list(t, k, ignore_t
Candidate:	token)

#undef k
#undef t
Candidate:	keyword token values.

//
Candidate:	keyword set changes, they
Candidate:	keywords, terminated by i
Candidate:	keyword[] = {
    token_l
Candidate:	keyword array contains th
Candidate:	keywords, 3 future
  // r
Candidate:	keyword) == 25 + 3 + 3 + 
Candidate:	keywords into hashtable.

Candidate:	keyword[i] != illegal; i+
Candidate:	keyword[i];
    unsigned 
Candidate:	keyword hashtable\n", col
Candidate:	keyword lookup!");
  }

 
Candidate:	token_h_
#define v8_token
Candidate:	token_h_

namespace v8 { 
Candidate:	token_list takes a list o
Candidate:	token name, string is the
Candidate:	token categories as follo
Candidate:	tokens
//   k: keyword to
Candidate:	tokens
//   f: future (re
Candidate:	tokens

// ignore_token i
Candidate:	token is a convenience ma
Candidate:	token_list call. it does

Candidate:	tokens belonging to the r
Candidate:	token(name, string, prece
Candidate:	token_list(t, k, f)      
Candidate:	token - not able to scan.
Candidate:	token {
 public:
  // all
Candidate:	token values.
#define t(n
Candidate:	token_list(t, t, ignore_t
Candidate:	token)
    num_tokens
  }
Candidate:	tokens
  };
#undef t

#if
Candidate:	token name
  // (e.g. "lt
Candidate:	token lt).
  static const
Candidate:	tokens);
    return name_
Candidate:	token string
  // (.e., "
Candidate:	token lt) or null if the 
Candidate:	token doesn't
  // have a
Candidate:	tokens);
    return strin
Candidate:	tokens);
    return prece
Candidate:	tokens];
#endif
  static 
Candidate:	tokens];
  static int8_t 
Candidate:	tokens];
};

} }  // name
Candidate:	token_h_

Candidate:	keyword tokens
//   k: ke
Candidate:	keyword tokens
//   f: fu
Candidate:	keyword tokens

// ignore
Candidate:	keywords (ecma-262, secti
Candidate:	keywords or future reserv
Candidate:	keyword value if str is a
Candidate:	keyword;
  // returns ide
Candidate:	api.h"
#include "bootstra
Candidate:	apinamedsecuritycheck(key
Candidate:	apiindexedsecuritycheck(i
Candidate:	tokens in the
  // curren
Candidate:	token() == global->securi
Candidate:	token()) return true;
  }
Candidate:	tokens in the
  // curren
Candidate:	token() == global->securi
Candidate:	token()) return true;
  }
Candidate:	key, v8::accesstype type)
Candidate:	key_handle(key);
  handle
Candidate:	key);
  handle<object> da
Candidate:	key));
  bool result = fa
Candidate:	key_handle),
            
Candidate:	key = factory::stack_over
Candidate:	key));
  handle<object> e
Candidate:	api after operations that
Candidate:	key,
                    
Candidate:	token::assign)
    read(n
Candidate:	key.
  read(node->obj());
Candidate:	key());
  // if the node'
Candidate:	keyed-load stub used? */ 
Candidate:	keyed_load_generic_smi, v
Candidate:	keyedloadgenericsmi)     
Candidate:	keyed_load_generic_symbol
Candidate:	keyedloadgenericsymbol)  
Candidate:	keyed_load_generic_slow, 
Candidate:	keyedloadgenericslow)    
Candidate:	keyed-load stubs are hit.
Candidate:	keyed_load_function_proto
Candidate:	keyedloadfunctionprototyp
Candidate:	keyed_load_string_length,
Candidate:	keyedloadstringlength)   
Candidate:	keyed_load_array_length, 
Candidate:	keyedloadarraylength)    
Candidate:	keyed_load_constant_funct
Candidate:	keyedloadconstantfunction
Candidate:	keyed_load_field, v8.keye
Candidate:	keyedloadfield)          
Candidate:	keyed_load_callback, v8.k
Candidate:	keyedloadcallback)       
Candidate:	keyed_load_interceptor, v
Candidate:	keyedloadinterceptor)    
Candidate:	keyed_store_field, v8.key
Candidate:	keyedstorefield)         
Candidate:	api.cc.
  static void fat
Candidate:	api.h"
#include "debug.h"
Candidate:	key thread_state_key =
  
Candidate:	key =
    internal::threa
Candidate:	key();

// constructor fo
Candidate:	key) ==
           lazily
Candidate:	key, null);
    return tr
Candidate:	key));
  if (state == nul
Candidate:	key, null);
  state->unli
Candidate:	key) == null);
  threadst
Candidate:	key, reinterpret_cast<voi
Candidate:	apinatives.js %source_dir
Candidate:	key |
            makefil
Candidate:	key} = .*/, "#{key} = #{c
Candidate:	key} = #{config::config[k
Candidate:	key]}")
          end
   
Candidate:	key |
            config_
Candidate:	key]}\"")
          end
 
Candidate:	api.hrl").

-record(user,
Candidate:	api:find_cookie_val("sess
Candidate:	api:set_content_type("tex
Candidate:	keysearch(cookie, #user.c
Candidate:	password) ->
    session_
Candidate:	password:"}},
	       {td
Candidate:	password},
				 {type, pa
Candidate:	password},
				 {size, "2
Candidate:	api:queryvar(a, "nr"),yaw
Candidate:	api:queryvar(a,"form")} o
Candidate:	api.hrl").
-include("defs
Candidate:	api:parse_multipart_post(
Candidate:	api:find_cookie_val("mail
Candidate:	api:set_content_type("tex
Candidate:	api:url_encode(from)}],[]
Candidate:	api:url_encode(to)}],[]},
Candidate:	api:url_encode(cc)}],[]},
Candidate:	api:url_encode(decode(h#m
Candidate:	api:url_encode(subject)}]
Candidate:	api:url_encode(quoted)}],
Candidate:	api:htmlize(wrap_text(dec
Candidate:	api:url_encode(filename),
Candidate:	api:htmlize(wrap_text(msg
Candidate:	api:mime_type(filename);

Candidate:	api:mime_type(filename);

Candidate:	api:mime_type(filename);

Candidate:	api:mime_type(filename)
	
Candidate:	api:url_encode(filename),
Candidate:	api:url_encode(filename),
Candidate:	api:parse_multipart(d, st
Candidate:	api:mime_type(filename) o
Candidate:	token_addrs(addrstr, [], 
Candidate:	token_addrs([], [], _) ->
Candidate:	token_addrs([], acc, _) -
Candidate:	token_addrs([c=$"|r], acc
Candidate:	token_addrs(r, [c|acc], f
Candidate:	token_addrs([c=$"|r], acc
Candidate:	token_addrs(r, [c|acc], t
Candidate:	token_addrs([c=$,|r], acc
Candidate:	token_addrs(r, [], false)
Candidate:	token_addrs([c|r], acc, i
Candidate:	token_addrs(r, [c|acc], i
Candidate:	tokens(str, " \t"),
    #
Candidate:	tokens(header, ";"),
    
Candidate:	tokens ~p at "
				  "lin
Candidate:	key, []) -> [];
mail_head
Candidate:	key, val) -> key++val++"\
Candidate:	key++val++"\r\n".

compos
Candidate:	keysearch(cookie, 1, c) o
Candidate:	keysearch(cookie, 1, c) o
Candidate:	keyreplace(cookie,1,c,
		
Candidate:	keydelete(cookie, 1, c),

Candidate:	keysearch(cookie, 1, c) o
Candidate:	keyreplace(
				      coo
Candidate:	keysearch(cookie, 1, c) o
Candidate:	keyreplace(
				      coo
Candidate:	keysearch(cookie, 1, c) o
Candidate:	keyreplace(
				      coo
Candidate:	keysearch(cookie, 1, c) o
Candidate:	keysearch(num, #satt.num,
Candidate:	keysearch(fname, #satt.fi
Candidate:	keydelete(a#satt.num, #sa
Candidate:	key = lowercase(string:st
Candidate:	key, value, headers),
	  
Candidate:	key|options] = string:tok
Candidate:	key_value(o) || o <- opti
Candidate:	key,opts}.


parse_key_va
Candidate:	key_value(o) ->
    parse
Candidate:	key_value(o, []).

parse_
Candidate:	key_value([], acc) ->
   
Candidate:	key_value([$=|rest], acc)
Candidate:	key = lowercase(string:st
Candidate:	key, value};
parse_key_va
Candidate:	key_value([c|cs], acc) ->
Candidate:	key_value(cs, [c|acc]).


Candidate:	key, l, default) ->
    c
Candidate:	keysearch(key, 1, l) of
	
Candidate:	key, 1, l) of
	{value, {_
Candidate:	keysearch("boundary",1,op
Candidate:	keysearch("boundary",1,op
Candidate:	keysearch("boundary",1,op
Candidate:	keysearch("boundary",1,op
Candidate:	keysearch("boundary",1,op
Candidate:	keysearch("boundary",1,op
Candidate:	keysearch("filename", 1, 
Candidate:	key, keylist) ->
    geto
Candidate:	keylist) ->
    getopt(ke
Candidate:	key, keylist, undefined).
Candidate:	keylist, undefined).

get
Candidate:	key, keylist, default) ->
Candidate:	keylist, default) ->
    
Candidate:	keysearch(key, 1, keylist
Candidate:	key, 1, keylist) of
	fals
Candidate:	keylist) of
	false ->
	  
Candidate:	password:"}},
	       {td
Candidate:	password},
				 {type, pa
Candidate:	password},
				 {size, "2
Candidate:	password) ->
    case sta
Candidate:	password)) of
	{ok, _} ->
Candidate:	password)};
	{error, reas
Candidate:	password) ->
    session_
Candidate:	password}, self()},
    r
Candidate:	password, nr) ->
    req 
Candidate:	password) of
	[{ok,msg}] 
Candidate:	password) ->
    case pop
Candidate:	password) of
	[{ok, stat}
Candidate:	password) ->
    case pop
Candidate:	password) of
	[{ok, stats
Candidate:	password) of
		{error, re
Candidate:	password) ->
    proc_lib
Candidate:	password, self()]),
    r
Candidate:	password, from) ->
    ca
Candidate:	password,
			    cmd=comm
Candidate:	tokens = tokenize(lists:f
Candidate:	tokenize(lists:flatten(in
Candidate:	tokens),
    revtext = eh
Candidate:	tokens) ->
    parse(toke
Candidate:	tokens, []).

parse([], a
Candidate:	tokenize(input, dataacc, 
Candidate:	tokenacc, linenr)

tokeni
Candidate:	tokenize([], [], tokens, 
Candidate:	tokens, _line) ->
    lis
Candidate:	tokens);
tokenize([], acc
Candidate:	tokenize([], acc, tokens,
Candidate:	tokens, line) ->
    list
Candidate:	tokens]);
tokenize([$<,$!
Candidate:	tokenize([$<,$!,$-,$-|r0]
Candidate:	tokens, l0) ->
    {r1, l
Candidate:	tokenize(r1, acc, tokens,
Candidate:	tokens, l1);
tokenize([$<
Candidate:	tokenize([$<|r0], acc, to
Candidate:	tokens, l0) ->
    {tag,r
Candidate:	token(tag, r1, [tag|token
Candidate:	tokens], l1);
	true ->
	 
Candidate:	token(tag, r1, [tag,data|
Candidate:	tokens], l1)
    end;
tok
Candidate:	tokenize([c=$\n|r0], acc,
Candidate:	tokens, l) ->
    tokeniz
Candidate:	tokenize(r0, [c|acc], tok
Candidate:	tokens, l+1);
tokenize([c
Candidate:	tokenize([c=$\r|r0], acc,
Candidate:	tokens, l) ->
    tokeniz
Candidate:	tokenize(r0, [c|acc], tok
Candidate:	tokens, l+1);
tokenize([c
Candidate:	tokenize([c|r0], acc, tok
Candidate:	tokens, l) ->
    tokeniz
Candidate:	tokenize(r0, [c|acc], tok
Candidate:	tokens, l).

%

next_toke
Candidate:	token({begin_tag, script,
Candidate:	tokens, l) ->
    {data, 
Candidate:	tokenize(r1, [], [{data, 
Candidate:	tokens], l1);
next_token(
Candidate:	token({begin_tag, style, 
Candidate:	tokens, l) ->
    {data, 
Candidate:	tokenize(r1, [], [{data, 
Candidate:	tokens], l1);
next_token(
Candidate:	token(_tag, r, tokens, l)
Candidate:	tokens, l) ->
    tokeniz
Candidate:	tokenize(r, [], tokens, l
Candidate:	tokens, l).

%% '<' <id> 
Candidate:	token(i, [], l).

%

scan
Candidate:	token(r, [], l).

%

scan
Candidate:	token([], acc, l) ->
    
Candidate:	token(r=[$>|_], acc, l) -
Candidate:	token(r=[$<|_], acc, l) -
Candidate:	token(r=[$=|_], acc, l) -
Candidate:	token([c|r], acc, l0) ->

Candidate:	token(r, [c|acc], l0)
   
Candidate:	key, []) -> [];
mail_head
Candidate:	key, val) -> key++val++"\
Candidate:	key++val++"\r\n".

%%

to
Candidate:	api.hrl").
-include_lib("
Candidate:	api:parse_multipart_post(
Candidate:	keysearch(fn,2,files) of

Candidate:	keysearch(fn, 2, files) o
Candidate:	keymember(y,2,files))],
	
Candidate:	keysearch(file, 2, files)
Candidate:	keydelete(filename, 2, ol
Candidate:	keysearch(fname, 1, descr
Candidate:	keysearch(fname, 1, descr
Candidate:	keysort(2,delfiles), root
Candidate:	keysort(2,cpfiles), root,
Candidate:	keydelete("password", 1, 
Candidate:	keydelete(pid, 1, session
Candidate:	keydelete(sid, 2, session
Candidate:	keysearch(sid, 2, session
Candidate:	keysearch(sid, 2, session
Candidate:	keysearch(sid, 2, session
Candidate:	keysort(2,files)),
	    c
Candidate:	keysort(2,files)) of
		fa
Candidate:	keysort(2,files)),
	    p
Candidate:	key, keylist) ->
    geto
Candidate:	keylist) ->
    getopt(ke
Candidate:	key, keylist, undefined).
Candidate:	keylist, undefined).

% g
Candidate:	key, keylist, default) wh
Candidate:	keylist, default) when at
Candidate:	key) ->
%     getopt(atom
Candidate:	key), keylist, default);

Candidate:	keylist, default);
getopt
Candidate:	key, keylist, default)  -
Candidate:	keylist, default)  ->
   
Candidate:	keysearch(key, 1, keylist
Candidate:	key, 1, keylist) of
	fals
Candidate:	keylist) of
	false ->
	  
Candidate:	key, keylist) when atom(k
Candidate:	keylist) when atom(key) -
Candidate:	key) ->
    getopt_option
Candidate:	key), keylist);
getopt_op
Candidate:	keylist);
getopt_options(
Candidate:	key, keylist) ->
    case
Candidate:	keylist) ->
    case list
Candidate:	keysearch(key, 1, keylist
Candidate:	key, 1, keylist) of
	{val
Candidate:	keylist) of
	{value, tupl
Candidate:	password/3,
	 storenewpag
Candidate:	password/3, storefiles/3,
Candidate:	password/3, changepasswor
Candidate:	password2/3, getthumb/3,

Candidate:	password/1]).
-export([im
Candidate:	password protected page "
Candidate:	password fields - otherwi
Candidate:	password "
	 "then the sy
Candidate:	password of the page if "
Candidate:	password: </td>",
	     "
Candidate:	password_entry("password1
Candidate:	password1", 8, passwd),
	
Candidate:	password: </td>",
	     "
Candidate:	password_entry("password2
Candidate:	password2", 8, passwd),
	
Candidate:	password = getopt("passwo
Candidate:	password", params, ""),
 
Candidate:	password(page, password, 
Candidate:	password, root, prefix) o
Candidate:	password, prefix);
			tru
Candidate:	password, page}, root);
	
Candidate:	password = getopt("passwo
Candidate:	password", params),
    e
Candidate:	password
    {file,filedi
Candidate:	password,email,time,who,t
Candidate:	password = getopt("passwo
Candidate:	password", params),
    a
Candidate:	password(page, password, 
Candidate:	password, root, prefix) o
Candidate:	password(page, root, pref
Candidate:	password    = getopt("pas
Candidate:	password", params),
    t
Candidate:	password", password),
		 
Candidate:	password),
		    "<table 
Candidate:	password="++
			  str2url
Candidate:	password)++"'")]),
	     
Candidate:	password,
	  node,
	  tex
Candidate:	password", _opts}}|res], 
Candidate:	password});
addfilechunk(
Candidate:	password ->
    password 
Candidate:	password = state#addfile.
Candidate:	password,
    newpw = mer
Candidate:	password, data),
    addf
Candidate:	password = newpw});

addf
Candidate:	password = state#addfile.
Candidate:	password,
    filepath = 
Candidate:	password(page, password, 
Candidate:	password, root, prefix) o
Candidate:	password, page}, root)};

Candidate:	password    = getopt("pas
Candidate:	password", params),

    
Candidate:	password", password)])
	 
Candidate:	password)])
	     ],
	   
Candidate:	password = getopt("passwo
Candidate:	password", params, ""),
 
Candidate:	password(page, password, 
Candidate:	password, root, prefix) o
Candidate:	password, page}, root);
	
Candidate:	password    = getopt("pas
Candidate:	password", params),

    
Candidate:	password", password)])
		
Candidate:	password)])
		     ],
		 
Candidate:	password = getopt("passwo
Candidate:	password", params, ""),
 
Candidate:	password(page, password, 
Candidate:	password, root, prefix) o
Candidate:	password, page}, root);
	
Candidate:	password(dest, "", root, 
Candidate:	password(dest, root, pref
Candidate:	password = getopt("passwo
Candidate:	password", params, ""),


Candidate:	password(dest, password, 
Candidate:	password, root, prefix) o
Candidate:	password, page}, root);
	
Candidate:	password, prefix) ->
    
Candidate:	password="++str2urlencode
Candidate:	password)}.


redirect_ed
Candidate:	password, prefix) ->
    
Candidate:	password),
    {redirect_
Candidate:	password="++urlpw}.

redi
Candidate:	password.yaws?node="++
  
Candidate:	password = getopt("passwo
Candidate:	password", params, ""),


Candidate:	password(page, password, 
Candidate:	password, root, prefix) o
Candidate:	password, page}, root);
	
Candidate:	password = getopt("passwo
Candidate:	password", params),
    

Candidate:	password", password),
			
Candidate:	password),
			    p(),
		
Candidate:	password = getopt("passwo
Candidate:	password", params, ""),
 
Candidate:	password(page, password, 
Candidate:	password, root, prefix) o
Candidate:	password, page}, root);
	
Candidate:	password(page, root, pref
Candidate:	password", 1, values)],
 
Candidate:	password", page,
	     [p
Candidate:	password protected - prov
Candidate:	password "
		"and hit the
Candidate:	password.yaws","f",
		   
Candidate:	password: ",
		     passw
Candidate:	password_entry("password"
Candidate:	password",8),
		     inpu
Candidate:	password.focus();")
		   
Candidate:	password(params, root, pr
Candidate:	password = getopt("passwo
Candidate:	password", params, ""),
 
Candidate:	password(page, password, 
Candidate:	password, root, prefix) o
Candidate:	password, root, prefix, s
Candidate:	password(page, root, pref
Candidate:	password="", email=""}).

Candidate:	password=passwd,
				    
Candidate:	password=passwd,
					   
Candidate:	password=newpw,
				     
Candidate:	password, state#sid.email
Candidate:	password, root, prefix, s
Candidate:	password, oldtxt, sid);
	
Candidate:	password, prefix)
	    en
Candidate:	password, content, sid) -
Candidate:	password"),
		input("hidd
Candidate:	password", password),
		h
Candidate:	password),
		hr()])
	  ],
Candidate:	password(params, root, pr
Candidate:	password has been mailed 
Candidate:	password(page, password, 
Candidate:	password, root, prefix) -
Candidate:	password -> true;
		_    
Candidate:	password = getopt("passwo
Candidate:	password", params, ""),


Candidate:	password(page, password, 
Candidate:	password, root, prefix) o
Candidate:	password, root, prefix);

Candidate:	password(page, root, pref
Candidate:	password, root, prefix) -
Candidate:	password", password)
			 
Candidate:	password)
			   ])], fals
Candidate:	password(params, root, pr
Candidate:	password setting for page
Candidate:	password leave "
	 "the n
Candidate:	passwords blank."),
     
Candidate:	password2.yaws?node="++
	
Candidate:	password: </td>"
	     "<
Candidate:	password_entry("password"
Candidate:	password", 8),
	     "</t
Candidate:	password: </td>"
	     "<
Candidate:	password_entry("password1
Candidate:	password1", 8),
	     "</
Candidate:	password: </td>"
	     "<
Candidate:	password_entry("password2
Candidate:	password2", 8),
	     "</
Candidate:	password.focus();")
	    
Candidate:	password2(params, root, p
Candidate:	password", params),
    p
Candidate:	password1", params),
    
Candidate:	password2", params),

   
Candidate:	password_mismatch, page},
Candidate:	password, page}, root)
	 
Candidate:	password = getopt("passwo
Candidate:	password", params),
    t
Candidate:	password", password),
		 
Candidate:	password),
		    input("h
Candidate:	password1", params),
    
Candidate:	password2", params),
    
Candidate:	password", p1),
			    in
Candidate:	passwords_differ,p1,p2}, 
Candidate:	password",
	 "the passwor
Candidate:	password of " ++ page ++ 
Candidate:	password_entry(name, size
Candidate:	password name=", name,"  
Candidate:	password_entry(name, size
Candidate:	password name=", name,"  
Candidate:	password, page}, root) ->
Candidate:	password",
	     [p("you 
Candidate:	password"),
	      p("to 
Candidate:	password fill "
		"in you
Candidate:	password</i>. if you are 
Candidate:	password."),
	      form(
Candidate:	password.yaws",
		   [inp
Candidate:	password")])
	     ], fal
Candidate:	password([file]) ->
    c
Candidate:	password is: '~s'\n", [pw
Candidate:	tokens(plugindata, " "),

Candidate:	tokens(argstring, "="),
 
Candidate:	key,val] = string:tokens(
Candidate:	key,val}|acc]).

Candidate:	api:getconf(),
    root =
Candidate:	api:getconf(),
    root =
Candidate:	keysearch("prefix", 1, ar
Candidate:	keysort(2,files)) ++
    
Candidate:	api.hrl").


get_path_pre
Candidate:	api:parse_multipart_post(
Candidate:	api:url_decode(p),
	    p
Candidate:	api:url_decode(p),
	    p
Candidate:	api:parse_query(arg),
	  
Candidate:	api:parse_post(arg),
    
Candidate:	api:url_decode(p),
    pr
Candidate:	api:parse_query(arg),
   
Candidate:	api:url_decode(p),
    pr
Candidate:	api:url_decode(p),
    pr
Candidate:	password. ''it's the word
Candidate:	password
to the entire pa
Candidate:	password of this page is 
Candidate:	password has password loc
Candidate:	password lock
k 
jhhb 
Candidate:	password rules*

pages ca
Candidate:	passwords when the page i
Candidate:	password then it cannot b
Candidate:	password. follow one of t
Candidate:	password. but individual 
Candidate:	password ''locked''.





Candidate:	password. follow one of t
Candidate:	password. ''it's the word
Candidate:	password
k hto the entire
Candidate:	password.
ha/ajhhb  
Candidate:	password. ''it's the word
Candidate:	password.
haahaajh
Candidate:	api.hrl.
%%%
%%% @type ya
Candidate:	api.hrl").
-include("yaws
Candidate:	api:setconf(gconf, newsco
Candidate:	api:setconf(gconf, newsco
Candidate:	api:getconf(),
    newsco
Candidate:	api:setconf(gconf, newsco
Candidate:	api:setconf(gconf, sconfs
Candidate:	api:getconf().
%    yaws_
Candidate:	api:getconf(),
    yapps1
Candidate:	tokens(bootstrapyapps,","
Candidate:	key for "bootstrap yapps"
Candidate:	keyreplace(?yapp_list, 1,
Candidate:	keyreplace(?yapp_list, 1,
Candidate:	api
-export([add_handler/
Candidate:	api
-export([list/2, add/
Candidate:	api
-export([start_link/1
Candidate:	api
%%===================
Candidate:	keyvalue}}, _from, state)
Candidate:	keyvalue),
    {reply, re
Candidate:	key}}, _from, state) ->
 
Candidate:	key),
    {reply, reply, 
Candidate:	key,
	  value
	  }).

ini
Candidate:	key=yapp_reg, value=yappr
Candidate:	keyvalue) ->
    {atomic,
Candidate:	keyvalue)
				      end),
Candidate:	keyreplace(srvid, 1, yr, 
Candidate:	keydelete(srvid,1,yr);
		
Candidate:	keyreplace(srvid, 1, yr, 
Candidate:	keymember(yappurl, 1, url
Candidate:	keyreplace(yappurl, 1, ur
Candidate:	keymember(yappurl, 1, url
Candidate:	keydelete(yappurl, 1, url
Candidate:	api.
%%% <p>the default y
Candidate:	api
-export([list/1, regi
Candidate:	api
-export([start_link/2
Candidate:	api
%%===================
Candidate:	api
-export([start_link/1
Candidate:	api functions
%%=========
Candidate:	keyfile,
	 certfile,
	 ve
Candidate:	password,
	 cacertfile,
	
Candidate:	api.hrl
%%% author  : cla
Candidate:	key,           
	    valu
Candidate:	keywords="x86 ppc sparc a
Candidate:	token is recognized, or
%
Candidate:	token([]) -> {more, []};

Candidate:	token(eof) -> {done, eof,
Candidate:	token([c | rest]) ->
    
Candidate:	token_identifier(c) of
	i
Candidate:	token}, rest};
	token -> 
Candidate:	token -> {done, {ok, toke
Candidate:	token}, rest}
    end.

t
Candidate:	token_identifier(c) ->
  
Candidate:	token is only valid as an
Candidate:	token({charlist, cache}, 
Candidate:	token({oldchars ++ charli
Candidate:	tokenoreof, {chars, cache
Candidate:	token({chars, cache}, kt)
Candidate:	token(chars) of
	{done, {
Candidate:	token, c, kv) ->
    pars
Candidate:	token, c, kv, false).
par
Candidate:	token, {chars, cache} = c
Candidate:	token of
	eof -> {done, {
Candidate:	token(c,
	      fun(t, {c
Candidate:	token({chars, cache},
	  
Candidate:	token(c,
	      fun
		  (
Candidate:	token(c,
	      fun
		  (
Candidate:	token(cont,
	      fun(t,
Candidate:	key/2]).
-export([test/0]
Candidate:	keys
%%%                 
Candidate:	key, value}, {acc, cache2
Candidate:	key, cache3} =
		      ca
Candidate:	key of
			  l when is_lis
Candidate:	key, key}}})
		      end,
Candidate:	key}}})
		      end,
		  
Candidate:	key, encodedval]], cache4
Candidate:	key, encodedval] | acc], 
Candidate:	key is a reference, we de
Candidate:	key, c1) ->
		      parse
Candidate:	key, c1, origcache, kv)
	
Candidate:	key is a string, we put i
Candidate:	key, {struct, props}) ->

Candidate:	key, props) of
        un
Candidate:	key, key});
        value
Candidate:	key});
        value ->
 
Candidate:	key, {struct, props}) ->

Candidate:	key, props) of
        un
Candidate:	key(key, {struct, props})
Candidate:	key, {struct, props}) ->

Candidate:	key, props).

%% store a 
Candidate:	keystr, value, {struct, p
Candidate:	key = list_to_atom(keystr
Candidate:	keystr),
    newprops = [
Candidate:	key, value} | proplists:d
Candidate:	key, props)],
    {struct
Candidate:	key/value pairs.

obj_fro
Candidate:	token is recognized, or
%
Candidate:	tokens are one of the fol
Candidate:	token([]) -> {more, []};

Candidate:	token(eof) -> {done, eof,
Candidate:	token("true" ++ rest) -> 
Candidate:	token("tru")	-> {more, "t
Candidate:	token("tr")	-> {more, "tr
Candidate:	token("t")	-> {more, "t"}
Candidate:	token("false" ++ rest) ->
Candidate:	token("fals")	-> {more, "
Candidate:	token("fal")	-> {more, "f
Candidate:	token("fa")	-> {more, "fa
Candidate:	token("f")	-> {more, "f"}
Candidate:	token("null" ++ rest) -> 
Candidate:	token("nul")	-> {more, "n
Candidate:	token("nu")	-> {more, "nu
Candidate:	token("n")	-> {more, "n"}
Candidate:	token([c | cs] = input) -
Candidate:	token(cs);	% eat whitespa
Candidate:	token(cs);	% eat whitespa
Candidate:	token(cs);	% eat whitespa
Candidate:	token(cs);	% eat whitespa
Candidate:	token(chars)
	end;
      
Candidate:	token(oldchars ++ charlis
Candidate:	tokenoreof, chars)

get_t
Candidate:	token(chars, kt) ->
    c
Candidate:	token(chars) of
	{done, {
Candidate:	token(chars, fun(t, c2) -
Candidate:	token must be string
	end
Candidate:	token(c, fun
        (col
Candidate:	token(c, fun
        (eof
Candidate:	token(c3, fun
           
Candidate:	token(c4, fun(t3, c5) ->

Candidate:	token(c, fun
        (eof
Candidate:	token(c2, fun
           
Candidate:	token(c3, fun(t3, c4) ->

Candidate:	key/2]).
-export([obj_sto
Candidate:	keys (i.e. {struct, propl
Candidate:	keys may be atoms or stri
Candidate:	keys always decoded to at
Candidate:	keys may be either string
Candidate:	keys.
%% note that order 
Candidate:	key, value}, acc) ->
	s =
Candidate:	key of
	    l when is_lis
Candidate:	key, key}})
	end,
	v = en
Candidate:	key}})
	end,
	v = encode(
Candidate:	key, {struct, props}) whe
Candidate:	key, props) of
        un
Candidate:	key, key});
        value
Candidate:	key});
        value ->
 
Candidate:	key, {struct, props}) whe
Candidate:	key, props) of
        un
Candidate:	key(key, {struct, props})
Candidate:	key, {struct, props}) ->

Candidate:	key, props).

%% store a 
Candidate:	keylist, value, {struct, 
Candidate:	key = list_to_atom(keylis
Candidate:	keylist),
    {struct, [{
Candidate:	key, value} | proplists:d
Candidate:	key, props)]}.

%% create
Candidate:	key/value pairs.

obj_fro
Candidate:	keysort(1, props1),
    l
Candidate:	keysort(1, props2),
    p
Candidate:	keysearch(elemname,1,list
Candidate:	tokens(binary_to_list(b),
Candidate:	tokens(l, [$\s, $\t]) of

Candidate:	api.hrl").
-include("yaws
Candidate:	api:setconf(gc, [scs]).


Candidate:	api:setconf(gconf, sconfs
Candidate:	api:code_to_phrase(code),
Candidate:	api function
%% return {r
Candidate:	api:reformat_request(requ
Candidate:	api:reformat_header(heade
Candidate:	api:reformat_header(heade
Candidate:	tokenize_ua([], acc) ->
 
Candidate:	tokenize_ua([$\\ , c|t], 
Candidate:	tokenize_ua(t, [c|acc]);

Candidate:	tokenize_ua([$(|t], acc) 
Candidate:	tokenize_ua(t, [popen | a
Candidate:	tokenize_ua([$)|t], acc) 
Candidate:	tokenize_ua(t, [pclose | 
Candidate:	tokenize_ua([c|t], acc) -
Candidate:	tokenize_ua(t, [c|acc]).

Candidate:	tokenize_ua(line, [])) of
Candidate:	tokens(auth, ":") of
		[u
Candidate:	keyfile/1, ssl_keyfile/2,
Candidate:	keyfile/2,
	 ssl_certfile
Candidate:	keyfile(s)      -> s#ssl.
Candidate:	keyfile.
ssl_certfile(s) 
Candidate:	keyfile(s, keyfile)      
Candidate:	keyfile)           -> s#s
Candidate:	keyfile = keyfile}.
ssl_c
Candidate:	keyfile}.
ssl_certfile(s,
Candidate:	key, list, def) ->
    ca
Candidate:	keysearch(key, 1, list) o
Candidate:	key, 1, list) of
	{value,
Candidate:	key(yaws) of
	    {ok, l}
Candidate:	keysearch(modules, 1, l) 
Candidate:	password/1, ssl_password/
Candidate:	password/2,
	 ssl_cacertf
Candidate:	password(s)     -> s#ssl.
Candidate:	password.
ssl_cacertfile(
Candidate:	password(s, password)    
Candidate:	password)         -> s#ss
Candidate:	password = password}.
ssl
Candidate:	password}.
ssl_cacertfile
Candidate:	api.hrl").

-export([out4
Candidate:	api:htmlize(path), 
	 " w
Candidate:	api.erl
%%% author  : cla
Candidate:	api).
-author('klacke@hyb
Candidate:	api.hrl").
-include("yaws
Candidate:	api:parse_multipart_post/
Candidate:	api:parse_multipart_post(
Candidate:	api:htmlize_char(ch);
eht
Candidate:	api:htmlize(bin);

ehtml_
Candidate:	api:htmlize_char(ch), bef
Candidate:	api:htmlize(bin), before,
Candidate:	api:parse_query(arg),
		 
Candidate:	api:parse_post(arg),
		  
Candidate:	api:getconf(),
    case {
Candidate:	tokens(decpath, "?") of
	
Candidate:	keysearch(boundary, 1, li
Candidate:	key(line, [], []),
    pa
Candidate:	key([], key, value) ->
  
Candidate:	key, value) ->
    make_p
Candidate:	key, value, []);
parse_ar
Candidate:	key([$;|line], key, value
Candidate:	key, value) ->
    make_p
Candidate:	key, value, [$;|line]);
p
Candidate:	key([$ |line], key, value
Candidate:	key, value) ->
    parse_
Candidate:	key(line, key, value);
pa
Candidate:	key, value);
parse_arg_ke
Candidate:	key([$=|line], key, value
Candidate:	key, value) ->
    parse_
Candidate:	key, value, false, false)
Candidate:	key([c|line], key, value)
Candidate:	key, value) ->
    parse_
Candidate:	key(line, [c|key], value)
Candidate:	key], value).
    
%
% we
Candidate:	key, valueacc, inquoteboo
Candidate:	key, value, _, _) ->
    
Candidate:	key, value, []);
parse_ar
Candidate:	key, value, quote, begun)
Candidate:	key, [$"|value], quote, b
Candidate:	key, value, false, _) ->

Candidate:	key, value, true, true);

Candidate:	key, value, true, _) ->
 
Candidate:	key, value, line);
parse_
Candidate:	key, value, false, _) ->

Candidate:	key, value, [$;|line]);
p
Candidate:	key, value, false, true) 
Candidate:	key, value, line);
parse_
Candidate:	key, value, false, false)
Candidate:	key, value, false, false)
Candidate:	key, value, quote, _) ->

Candidate:	key, [c|value], quote, tr
Candidate:	key, value, rest) ->
    
Candidate:	key, {yaws, to_lowerchar}
Candidate:	keysearch("content-dispos
Candidate:	keysearch(name, 1, parame
Candidate:	key(name), parameters};
	
Candidate:	key, [], key).

%% spec i
Candidate:	key).

%% spec is a typel
Candidate:	key, value}] list from th
Candidate:	key wil always be a regul
Candidate:	key) ->
    [{mkkey_rever
Candidate:	key_reverse(cur), undefin
Candidate:	key, [], key)];  %% cont 
Candidate:	key)];  %% cont keymode


Candidate:	keymode

do_parse_spec(<<
Candidate:	key, [], key)];

do_parse
Candidate:	key)];

do_parse_spec(<<$
Candidate:	key) ->
    do_parse_spec
Candidate:	key_reverse(cur), [], val
Candidate:	key, cur, _state) ->
    
Candidate:	key_reverse(cur), undefin
Candidate:	key_reverse(s) ->
    mkk
Candidate:	key(lists:reverse(s)).
mk
Candidate:	key(s) ->
    gc=get(gc),
Candidate:	key, value}]  or {eventta
Candidate:	key 	 = atom()
%% value =
Candidate:	key-value lists of more a
Candidate:	keysearch(var, 1, env) of
Candidate:	key,rest0} = parse_set_co
Candidate:	key(rest00, []),
    rest
Candidate:	key,value,quoted),
	    p
Candidate:	key,undefined,false),
	  
Candidate:	key([], acc) ->
    {list
Candidate:	key(t=[$=|_], acc) ->
   
Candidate:	key(t=[$;|_], acc) ->
   
Candidate:	key([c|t], acc) ->
    pa
Candidate:	key(t, [c|acc]).

%

pars
Candidate:	key, value, quoted) when 
Candidate:	key==undefined ->
    c#s
Candidate:	key=key,value=value,quote
Candidate:	key,value=value,quoted=qu
Candidate:	key, _value, _quoted) ->

Candidate:	key|format_set_cookie_opt
Candidate:	key,$=,$",c#setcookie.val
Candidate:	key,$=,c#setcookie.value|
Candidate:	key,undefined) -> [];
add
Candidate:	key,opt) -> [$;,key,$=,op
Candidate:	key,$=,opt].

format_set_
Candidate:	key) when atom(key) ->
  
Candidate:	key) ->
    getvar(arg, a
Candidate:	key));
getvar(arg,key) ->
Candidate:	key) ->
    case (arg#arg
Candidate:	key);
        'get' -> qu
Candidate:	key);
        _ -> undefi
Candidate:	key) when atom(key) ->
  
Candidate:	key) ->
    queryvar(arg,
Candidate:	key));
queryvar(arg, key)
Candidate:	key) ->
    parse = case 
Candidate:	keysearch(key,1,parse) of
Candidate:	key,1,parse) of
	{value,{
Candidate:	key) when atom(key) ->
  
Candidate:	key) ->
    postvar(arg, 
Candidate:	key));
postvar(arg, key) 
Candidate:	key) ->
    parse = case 
Candidate:	keysearch(key,1,parse) of
Candidate:	key,1,parse) of
	{value, 
Candidate:	key) ->
    case get({bin
Candidate:	key}) of
	undefined -> er
Candidate:	key});
	value -> value
  
Candidate:	key) ->
     case get({bi
Candidate:	key}) of
	undefined -> fa
Candidate:	api.hrl").
-include("yaws
Candidate:	api:stream_chunk_end(arg#
Candidate:	api:stream_chunk_deliver_
	KEY FOUND:	api:stream_chunk_deliver_
Candidate:	api:stream_chunk_end(pid)
Candidate:	tokens(host, ":") of
    
Candidate:	keysearch(k, 1, extraenv)
Candidate:	password in plain text.
	
Candidate:	password, "basic " ++ aut
Candidate:	password", password}
				
Candidate:	password}
				  ];
	{_use
Candidate:	password, _origstring} ->
Candidate:	api.hrl").
-include("yaws
Candidate:	api:htmlize(chars) | c#co
Candidate:	api, [f/2, fl/1, postvar/
Candidate:	api.hrl").~n', 
	      [g
Candidate:	tokens(tail, " =>\r\n\"")
Candidate:	keysearch(exports, 1, lis
Candidate:	key) ->
    erase(key).


Candidate:	key).

file_position_bof(
Candidate:	api.hrl").
-include("yaws
Candidate:	api:parse_url(url)) of
		
Candidate:	api:path_norm(authdir),
	
Candidate:	tokens(sc#sconf.servernam
Candidate:	tokens ~p at line ~w", [h
Candidate:	tokens(user, ":") of
		[n
Candidate:	tokenizer
toks(chars) ->

Candidate:	keysort(1,l)),
    l3 = a
Candidate:	keyfile", '=', val] ->
	 
Candidate:	keyfile = val}},
		    fl
Candidate:	key, '=', value] ->
	    
Candidate:	key,value} | c#sconf.opaq
Candidate:	keysearch(newsc#sconf.ser
Candidate:	keydelete(oldsc#sconf.ser
Candidate:	password", '=', val] ->
	
Candidate:	password = val}},
		    f
Candidate:	api.hrl").

%% todo:  a
Candidate:	keysearch(name, 3, header
Candidate:	keysearch(type, 1, attrib
Candidate:	keysearch(charset, 1, att
Candidate:	keysearch(language, 1, at
Candidate:	keysearch(mediatype, 1, a
Candidate:	keysearch(simplemediatype
Candidate:	keysearch(type++"/*", 1, 
Candidate:	keysearch("*/*", 1, accep
Candidate:	keysearch(charset, 1, acc
Candidate:	keysearch(language, 1, ac
Candidate:	keysearch(h, 1, acceptlan
Candidate:	keysearch("*", 1, acceptl
Candidate:	secret key string.

conne
Candidate:	api.hrl").
-include("yaws
Candidate:	api:getconf(),
	    case 
Candidate:	api:setconf(gc#gconf{trac
Candidate:	api:setconf(gc#gconf{trac
Candidate:	api:setconf(gc#gconf{trac
Candidate:	key} ->

	    %% not good
Candidate:	key = random:uniform(1 bs
Candidate:	key) of
			ok ->
			    p
Candidate:	key);
			error ->
			    
Candidate:	key)
		    end;
		err ->

Candidate:	key) ->
    case catch
	b
Candidate:	key}])),
	    {ok, fi} = 
Candidate:	key) ->
    case gen_tcp:
Candidate:	key);
	err ->
	    error_
Candidate:	key).

handle_a(a, gc, ke
Candidate:	key) ->
    case gen_tcp:
Candidate:	key} ->
		    res = yaws:
Candidate:	key} ->
		    gen_tcp:sen
Candidate:	key} ->
		    res = actl_
Candidate:	key} ->
		    a_status(a)
Candidate:	key} ->
		    a_load(a, m
Candidate:	key} ->
		    a_id(a),
		
Candidate:	key} ->
		    gen_tcp:sen
Candidate:	key string.

connect_file
Candidate:	key}]} ->
	    case gen_t
Candidate:	key};
		err ->
		    err

Candidate:	key} ->
	    str = s_cmd(
Candidate:	key, term),
	    io:forma
Candidate:	key, term) ->
    gen_tcp
Candidate:	key})),
    res = case ge
Candidate:	key} ->
			      gen_tcp:
Candidate:	api.hrl").
-include("../i
Candidate:	api:url_decode_q_split(ur
Candidate:	tokens(lists:reverse(l), 
Candidate:	tokens(lists:reverse(l), 
Candidate:	keysearch("destination", 
Candidate:	keysearch("overwrite", 3,
Candidate:	keysearch("depth", 3, hs)
Candidate:	api.hrl").
-include("yaws
Candidate:	keysearch(current_functio
Candidate:	keysearch(initial_call, 1
Candidate:	tokens = tokenize(input, 
Candidate:	tokenize(input, [], [], 1
Candidate:	tokens, {ehtml,[],0}, [],
Candidate:	tokens, stack, acc)

pars
Candidate:	tokens], ctag, stack, acc
Candidate:	tokens, ctag, stack, [{t,
Candidate:	tokens, {t,a,l}, [{ctag,a
Candidate:	tokens], {t,a,_}, [{ctag,
Candidate:	tokens, ctag, stack, [e|c
Candidate:	tokens], ctag = {t2,_a,l2
Candidate:	tokens, ctag, stack, acc)
Candidate:	tokens], ctag, stack, acc
Candidate:	tokens, ctag, stack, acc)
Candidate:	tokens, ctag, stack, [dat
Candidate:	tokenize(input, dataacc, 
Candidate:	tokenacc, linenr)

tokeni
Candidate:	tokenize([], [], tokens, 
Candidate:	tokens, _line) ->
    lis
Candidate:	tokens);
tokenize([], acc
Candidate:	tokenize([], acc, tokens,
Candidate:	tokens, line) ->
    list
Candidate:	tokens]);
tokenize([$<,$!
Candidate:	tokenize([$<,$!,$-,$-|r0]
Candidate:	tokens, l0) ->
    {r1, l
Candidate:	tokenize(r1, acc, tokens,
Candidate:	tokens, l1);
tokenize([$<
Candidate:	tokenize([$<|r0], acc, to
Candidate:	tokens, l0) ->
    {tag,r
Candidate:	token(tag, r1, [tag|token
Candidate:	tokens], l1);
	true ->
	 
Candidate:	token(tag, r1, [tag,data|
Candidate:	tokens], l1)
    end;
tok
Candidate:	tokenize([c=$\n|r0], acc,
Candidate:	tokens, l) ->
    tokeniz
Candidate:	tokenize(r0, [c|acc], tok
Candidate:	tokens, l+1);
tokenize([c
Candidate:	tokenize([c=$\r|r0], acc,
Candidate:	tokens, l) ->
    tokeniz
Candidate:	tokenize(r0, [c|acc], tok
Candidate:	tokens, l+1);
tokenize([c
Candidate:	tokenize([c|r0], acc, tok
Candidate:	tokens, l) ->
    tokeniz
Candidate:	tokenize(r0, [c|acc], tok
Candidate:	tokens, l).

%

next_toke
Candidate:	token({begin_tag, script,
Candidate:	tokens, l) ->
    {data, 
Candidate:	tokenize(r1, [], [{data, 
Candidate:	tokens], l1);
next_token(
Candidate:	token({begin_tag, style, 
Candidate:	tokens, l) ->
    {data, 
Candidate:	tokenize(r1, [], [{data, 
Candidate:	tokens], l1);
next_token(
Candidate:	token(_tag, r, tokens, l)
Candidate:	tokens, l) ->
    tokeniz
Candidate:	tokenize(r, [], tokens, l
Candidate:	tokens, l).

%% '<' <id> 
Candidate:	token(i, [], l).

%

scan
Candidate:	token(r, [], l).

%

scan
Candidate:	token([], acc, l) ->
    
Candidate:	token(r=[$>|_], acc, l) -
Candidate:	token(r=[$<|_], acc, l) -
Candidate:	token(r=[$=|_], acc, l) -
Candidate:	token([c|r], acc, l0) ->

Candidate:	token(r, [c|acc], l0)
   
Candidate:	api.hrl").

%%% #########
Candidate:	api:find_cookie_val(cooki
Candidate:	api:cookieval_to_opaque(c
Candidate:	api:cookieval_to_opaque(c
Candidate:	api:delete_cookie_session
	KEY FOUND:	api:delete_cookie_session
Candidate:	api:new_cookie_session(ne
Candidate:	api:setcookie(cookiename,
Candidate:	api:replace_cookie_sessio
	KEY FOUND:	api:replace_cookie_sessio
Candidate:	api.hrl").
-include("yaws
Candidate:	api
%%%------------------
Candidate:	keysearch(sc#sconf.server
Candidate:	keysearch(servername, #al
Candidate:	api.hrl").
-include("yaws
Candidate:	api:htmlize(yaws_api:url_
Candidate:	api:url_decode(dirname)),
Candidate:	api:htmlize(yaws_api:url_
Candidate:	api:url_decode(dirstr)),

Candidate:	api:stream_chunk_deliver_
	KEY FOUND:	api:stream_chunk_deliver_
Candidate:	api:stream_chunk_end(ypid
Candidate:	api:url_encode(name) ++ q
Candidate:	tokens(path, [$?]) of
	[d
Candidate:	tokens(binary_to_list(bin
Candidate:	keysort(pos, l0),

    l2
Candidate:	keysearch(name,1,descript
Candidate:	tokens(str, " \n") of
	["
Candidate:	keysearch(sid, #user.i, s
Candidate:	keydelete(sid, #user.i, s
Candidate:	keysearch(monitorref, #us
Candidate:	keydelete(monitorref, #us
Candidate:	keysearch(i, #user.i, sta
Candidate:	keydelete(i,#user.i,state
Candidate:	password) ->
    gen_serv
Candidate:	password}).
%% yaws never
Candidate:	password}, from, state0) 
Candidate:	password, 0, 
				    sta
Candidate:	api.hrl").
-include("yaws
Candidate:	api:reformat_request(
		 
Candidate:	api:reformat_header(heade
Candidate:	api:reformat_response(r);
Candidate:	api:reformat_request(
			
Candidate:	api:parse_url(h#headers.l
Candidate:	api.hrl").

%%% #########
Candidate:	api:url_decode(payload);

Candidate:	api:find_cookie_val(cooki
Candidate:	api:cookieval_to_opaque(c
Candidate:	api:delete_cookie_session
	KEY FOUND:	api:delete_cookie_session
Candidate:	api:new_cookie_session(ne
Candidate:	api:setcookie(cookiename,
Candidate:	api:setcookie(cookiename,
Candidate:	api:replace_cookie_sessio
	KEY FOUND:	api:replace_cookie_sessio
Candidate:	api
%%%------------------
Candidate:	api:htmlize(title), "</ti
Candidate:	api:htmlize(desc), "</des
Candidate:	keysort(5,is).


to_xml([
Candidate:	key, list, def) ->
    ca
Candidate:	keysearch(key, 1, list) o
Candidate:	key, 1, list) of
	{value,
Candidate:	api.hrl").
-include("yaws
Candidate:	api, [ehtml_expand/1]).


Candidate:	api:set_tty_trace(?gc_has
Candidate:	api:url_decode(path).

op
Candidate:	api:url_decode_q_split(ra
Candidate:	api:url_decode(path),
   
Candidate:	api:code_to_phrase(code),
Candidate:	api:code_to_phrase(416),

Candidate:	api:is_absolute_uri(url) 
Candidate:	tokens(decpath, "?") of
	
Candidate:	tokens(decpath, "?") of
	
Candidate:	keydelete(pid, 1, state#s
Candidate:	keyreplace(pid, 1, state#
Candidate:	keysearch(pid, 1, state#s
Candidate:	keyfile /= undefined ->
	
Candidate:	keyfile, ssl#ssl.keyfile}
Candidate:	keyfile};
	    true ->
		
Candidate:	key = ut#urltype.getpath,
Candidate:	key) of
	[{_key, spec, mt
Candidate:	key, spec, mtime1, spec, 
Candidate:	key, spec, mtime, spec, e
Candidate:	key = binary_to_list(send
Candidate:	key--"%%"}) of
		    unde
Candidate:	key = ut2#urltype.getpath
Candidate:	key) of
		[{_key, spec, m
Candidate:	key, spec, mtime1, spec, 
Candidate:	key, spec, mtime, spec, e
Candidate:	key, value}) -> put({bind
Candidate:	key}, value) end, l),
   
Candidate:	key = {ssi, file, delimit
Candidate:	key) of
	[{_, parts, mtim
Candidate:	key,d, mtime}),
		    ssi
Candidate:	keysearch(v, 1, bs) of
	{
Candidate:	keysearch("/", 1, sc#scon
Candidate:	password /= undefined ->

Candidate:	password, ssl#ssl.passwor
Candidate:	password};
	    true ->
	
Candidate:	password, _origstring} ->
Candidate:	password}, users) of
			t
Candidate:	password}, arg),
			    {
Candidate:	password) of
				{yes, _}
Candidate:	password}, arg),
				    
Candidate:	api.hrl").


-define(ttl,
Candidate:	api
%%%------------------
Candidate:	keypos, 2}]),
    {ok, un
Candidate:	key) ->
    case ets:look
Candidate:	key) of
	[y] ->
	    if
	
Candidate:	key));
		true ->
		    re
Candidate:	key),
		    ets:delete(?m
Candidate:	key),
		    trav_ets(n, n
Candidate:	key))
    end.

gnow() ->
Candidate:	api
-export([start_link/0
Candidate:	api.hrl").
-include("../i
Candidate:	api
%%===================
Candidate:	keysearch(id, 1, state#s.
Candidate:	api
%%%------------------
Candidate:	api.hrl").


%%% ########
Candidate:	api:find_cookie_val(cooki
Candidate:	api:cookieval_to_opaque(c
Candidate:	api:cookieval_to_opaque(c
Candidate:	api:delete_cookie_session
	KEY FOUND:	api:delete_cookie_session
Candidate:	api:new_cookie_session(ne
Candidate:	api:setcookie(cookiename,
Candidate:	api:replace_cookie_sessio
	KEY FOUND:	api:replace_cookie_sessio
Candidate:	api.hrl"). 


-define(elo
Candidate:	api:call_in_master(mnesia
Candidate:	api:parse_post(a),
		    
Candidate:	tokens(a#arg.appmoddata, 
Candidate:	tokens:str2terms("{hello,
Candidate:	tokenlists2terms(str2toke
Candidate:	tokenlists(string)).

str
Candidate:	tokenlists("")     -> [];
Candidate:	tokenlists(string) ->
   
Candidate:	tokens([], string, 1) of

Candidate:	tokens, _}, rest} ->
    
Candidate:	tokens | str2tokenlists(r
Candidate:	tokenlists(rest)]
    end
Candidate:	tokenlists2terms(lists) -
Candidate:	key to the datatype that 
Candidate:	keysort(2, ?mnesia(dirty_
Candidate:	key, l) ->
    {value, {_
Candidate:	keysearch(key, 1, l),
   
Candidate:	key, 1, l),
    val.

lk(
Candidate:	key, l, default) ->
    c
Candidate:	keysearch(key, 1, l) of
 
Candidate:	key, 1, l) of
    {value,
Candidate:	api.hrl").
-compile(expor
Candidate:	key in baseproto){
if(pro
Candidate:	key]===undefined){
proto[
Candidate:	key]=baseproto[key];
}
}

Candidate:	key];
}
}
}
for(var key i
Candidate:	key in baseclass){
if((ke
Candidate:	key!='prototype')&&(__cla
Candidate:	key]===undefined)){
__cla
Candidate:	key]=baseclass[key];
}
}

Candidate:	key];
}
}
}
}
if(proto.__
Candidate:	key in __class__){
newcla
Candidate:	key]=__class__[key];
}
ne
Candidate:	key];
}
newclass.tostring
Candidate:	key in obj){
out.push(rep
Candidate:	key)+":"+repr(obj[key]));
Candidate:	key]));
}
return "{"+out.
Candidate:	key=s[1].slice(1,-1);
}el
Candidate:	key=null;
}
this.paddingf
Candidate:	key){
if((typeof argument
Candidate:	key];
}else{
throw new mo
Candidate:	api.hrl").
-include_lib("
Candidate:	api:find_cookie_val("ssid
Candidate:	api:cookieval_to_opaque(v
Candidate:	api:delete_cookie_session
	KEY FOUND:	api:delete_cookie_session
Candidate:	api:queryvar(a, "user"),

Candidate:	api:queryvar(a, "url"),
	
Candidate:	api:queryvar(a, "password
Candidate:	api:new_cookie_session(se
Candidate:	api:redirect(url),
	     
Candidate:	api:setcookie("ssid",cook
Candidate:	api:parse_post(a),
    i2
Candidate:	api:replace_cookie_sessio
	KEY FOUND:	api:replace_cookie_sessio
Candidate:	keywords\" content=\"nort
Candidate:	keydelete(str,1, items)])
Candidate:	keysearch(desc, 1, junk),
Candidate:	keysearch(str, 1, junk),

Candidate:	keysearch(str, 1, items) 
Candidate:	password"},
	    {input, 
Candidate:	password},
		     {type, 
Candidate:	password")} of

	{{ok, us
Candidate:	api:setconf(gc, [[sc]]).

Time took: 0:01:44.928430
